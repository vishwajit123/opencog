
31 Dec 2016
-----------

psql en_pairs
\dt

select count(*) from atoms;
 18487291

loadmodule libPersistModule.so

sql-open learn-pairs linas asdf
sql-open en-pairs linas asdf

password authentication failed for user "linas"

sql-open opencog_test opencog_tester cheese

/etc/postgresql/9.6/main/pg_hba.conf looks OK...

So: I have en_pairs and 
 opencog_test | linas    | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
but the owner of the tables is opencog_tester

/var/log/postgresql/postgresql-9.6-main.log

2017-01-03 16:15:50 CST [2856-1] linas@en_pairs FATAL:  password authentication
failed for user "linas"
2017-01-03 16:15:50 CST [2856-2] linas@en_pairs DETAIL:  User "linas" has no password
assigned.


2017-01-01 17:20:54 CST [4829-1] opencog_tester@opencog_test ERROR:  insert or update
on table "atoms" violates foreign key constraint "atoms_space_fkey"
2017-01-01 17:20:54 CST [4829-2] opencog_tester@opencog_test DETAIL:  Key (space)=(2)
is not present in table "spaces".

(use-modules (opencog persist-sql))
(sql-open "en-pairs" "learner" "asdf")

\du
alter user learner password 'asdf';
grant CONNECT ON DATABASE en_pairs to learner;
grant SELECT,INSERT,UPDATE on table atoms to learner;

sql-open en-pairs learner asdf

it worked!
(sql-load)

18 million atoms

Loaded 9045489 atoms at height 2
Finished loading 18487291 atoms in total
12:35 to load .. !? 18487291 atoms/755 secs = 24.5K atoms/sec

psql -h localhost -U ubuntu lt_pairs 

ALTER USER ubuntu PASSWORD 'asdf';

========================================================
-----------------------------------------
lxc -- create an all-updated opencog-base

lxc-start -n opencog-base --daemon

time lxc-copy -n  opencog-learn -N learn-lt

------------------------------------
4 Jan 2016
----------
https://dumps.wikimedia.org/zhwiki/20170101/
https://dumps.wikimedia.org/zh_yuewiki/20170101/
https://dumps.wikimedia.org/frwiki/20170101/

lynx https://dumps.wikimedia.org/ltwiki/20170101/ltwiki-20170101-pages-articles-multistream.xml.bz2

time cat ltwiki-20170101-pages-articles-multistream.xml.bz2 |bunzip2 |/home/ubuntu/src/relex/src/perl/wiki-scrub.pl
real	4m58.871s
user	5m35.652s
sys	0m11.700s

find |wc gives 209011 total articles
find |wc gives 178514 after cat/template removal

createdb lt_pairs
createdb lt_morph
cat opencog/persist/sql/odbc/atom.sql | psql lt_pairs
cat opencog/persist/sql/odbc/atom.sql | psql lt_morph

=============================================================

time cat zh_yuewiki-20170101-pages-articles.xml.bz2 |bunzip2 |/home/ubuntu/src/relex/src/perl/wiki-scrub.pl

about 48 seconds
find |wc gives 67363 total articles
find |wc gives 49170 after cat/template removal

apt-get install fonts-arphic-ukai fonts-arphic-uming fonts-babelstone-han
fonts-wqy-zenhei fonts-hanazono

fonts-arphic-bkai00mp
fonts-arphic-bsmi00lp
fonts-arphic-gbsn00lp
fonts-arphic-gkai00mp

Arghh. None of the above provide the Kangxi radicals for the terminal.
Which I think are coming from fonts-wqy-microhei

U+2F13  Kangxi Radicals,

U+42AA  U+4401   CJK_Ext_A  CJK-Ext.A

createdb yue_pairs

cd ~/src/atomspace
cat opencog/persist/sql/odbc/atom.sql | psql yue_pairs

。。

\p{Block: CJK}   
\p{Block=CJK_Symbols_And_Punctuation} 
\p{Punct}
\p{InCJK}) 
\p{Close_Punctuation}   aka \p{Pe}   (close parent)
 \p{Final_Punctuation}   aka \p{Pf})  more quote-close or open.. things
\p{Ps} open quote


full stop

relex-server-port relex-server-host


; -- count-all -- Return the total number of atoms in the atomspace.
; -- cog-get-atoms -- Return a list of all atoms of type 'atom-type'
; -- cog-prt-atomspace -- Prints all atoms in the atomspace
; -- cog-count-atoms -- Count of the number of atoms of given type.
; -- cog-report-counts -- Return an association list of counts.


wtf 
(define (foo atom) (display "duude\n")(display atom) (newline) #f) 

WARNING: No known abbreviations for language 'yue', attempting fall-back
to English version..    FIXED

odbc is still logging! FIXED
CommLog           = No in /etc/odbcinst.ini

don't use "foo", it prints a warning .. better yet, don't warn! FIXED


below is due to bug opencog/relex#248 and is now fixed.
It  needed a new link-grammar version
link-grammar: Error: EMPTY-WORD.zzz must be defined!

link-grammar: Error: Word 'EMPTY-WORDzzz': Internal error: NULL X_node

link-grammar: Error: sentence_split(): Internal error detected
Warning: No parses found for:
港 區 全 國 人 大 代 表 係 代 表 香 港 居 民 響 中 華 人 民 共 和 國 全 國 人 民 代 表 大 會 行 使 國 家 立 法 權 嘅 代 表 ， 名 額 36 人 （1997 年 香 港 主 權 移 交 之 後 ）。


link-grammar: Error: EMPTY-WORD.zzz must be defined!

link-grammar: Error: Word 'EMPTY-WORDzzz': Internal error: NULL X_node

link-grammar: Error: sentence_split(): Internal error detected
Warning: No parses found for:
深 圳 習 慣 叫 特 區 範 圍 做 「 關 內 」， 而 特 區 範 圍 之 外 嘅 ，
包 括 寶 安 區 、 龍 崗 區 同 光 明 新 區 、 坪 山 新 區 就 叫 「 關 外
」； 由 「 關 外 」 入 特 區 叫 「 入 關 」， 反 之 係 「 出 關 」。

<title>永利街</title>  contains junk yest it does...


Started 5 Jan 2017 16:00 exactly.
ten minutes later: 5048 atoms -- so 500 atoms per minute...
after some halts and hiccups:
2211 articles after 1 hour = 37 articles/minute
18529 atoms after about 1 hour ...
or about 8.4 atoms per article... 

There are only about 48K articles, so it should conclude in 24 hours
...!?

hours later... 219127 atoms 6345 articles done ...
Now its about 34.5 atoms per article.. whoa ... 

java claims to have parsed 12424 sentences
11459 articles processed.
457009 atoms


29291 articles processed 19919 remaining
668042 atoms ...


; -- cog-report-counts -- Return an association list of counts.

(count-all)
(cog-report-counts)
(gc-stats)

... ram usage slowly increasing...

 (gc-stats)
((gc-time-taken . 315428672862) (heap-size . 3479842816) (heap-free-size
. 1406132224) (heap-total-allocated . 132540491040)
(heap-allocated-since-gc . 906048240) (protected-objects . 500)
(gc-times . 414))

(gc-stats)
((gc-time-taken . 327615529234) (heap-size . 3582787584) (heap-free-size
. 1584795648) (heap-total-allocated . 138942040624)
(heap-allocated-since-gc . 1123554048) (protected-objects . 500)
(gc-times . 422))

((gc-time-taken . 491224665617) (heap-size . 4601581568) (heap-free-size
. 2257489920) (heap-total-allocated . 211782122608)
(heap-allocated-since-gc . 399939472) (protected-objects . 500)
(gc-times . 485))


if (number-of-cells-collected-recently < GUILE_MIN_YIELD_X)
  then
    allocate-new-heap
  else
    run-a-collection

`scm_i_gc_grow_heap_p ()' and `scm_gc_for_newcell ()'.)


(WordSequenceLink lots of these ... 


 gcprof procedure in the statprof library
https://www.gnu.org/software/guile/manual/html_node/Statprof.html

guile-yue> (statprof-display)
%     cumulative   self             self     total             
time   seconds    seconds  calls    ms/call  ms/call       name
 49.18  11506.88  11506.88   13516   851.35   851.35  inc
  4.92  23397.33   1150.69      27 42618.08 866567.64  catch
  4.92  12657.57   1150.69     215  5352.04 58872.42  cog-map-type
  3.28    767.13    767.13    1420   540.23   540.23  char=?
  3.28    767.13    767.13     619  1239.30  1239.30  write-char
  3.28    767.13    767.13     372  2062.17  2062.17  memq
  3.28    767.13    767.13     182  4214.97  4214.97  call-with-output-string
  1.64   2684.94    383.56     182  2107.49 14752.41  tilde-dispatch
  1.64    383.56    383.56      29 13226.30 13226.30  close-port
  1.64    383.56    383.56     240  1598.18  1598.18  assv-ref
...
  0.00  12657.57      0.00     215     0.00 58872.42  cog-count-atoms

above over about 24K seconds total, so accurate... ish

(use-modules (statprof))
(statprof-reset 0 50000 #t) ;
(statprof-start)
(do-something)
(statprof-stop)
(statprof-display)
(gcprof (λ () (observe-text "1769 年 ： 伊 萬 克 雷 洛 夫 ， 俄 國 寓 言 作 家 1910 年 ： 威 廉  肖 克 利 （William Shockley）， 美 國 物 理 學 家 ， 有 份 發 明 半 導 體 ，1956 年 諾 貝 爾 物 理 獎 得 主 1915 年 ： 昂 山 ， 緬 甸 國 父 1921 年 ： 趙 無 極 ， 法 國 華 裔 畫 家 1974 年 ：Robbie Williams， 英 國 歌 手 1974 年 ： 馬 國 明 ， 香 港 無 綫 電 視 演 員 1981 年 ： 何 紫 綸 ， 香 港 模 特 兒 1990 年 ： 西 藏 第 十 一 世 班 禪 額 爾 德 尼 金 瑞 瑤 ， 台 灣 音 樂 經 理 人 1993 年 ： 宋 希 濂 ， 抗 日 戰 爭 同 國 共 內 戰 時 期 中 國 國 民 黨 將 軍 2006 年 ： 王 選 ， 中 國 計 算 機 學 者 ， 發 明 漢 字 激 光 照 排 技 術")))

Maybe use it in "observe-text"? ...

total time is correct...
... its a thread thing. staprof with threads is borked.
See comments in ./module/statprof.scm ~ Implementation notes ~


compute-mi.scm:		(for-each inc atom-list)
compute-mi.scm:		(define (inc atom) (set! cnt (+ cnt (tv-count
(cog-tv atom)))))

Maybe lots and lots of threads ... ? Seems to get very backed-up.
No .. only 14 threads

(hash-map->list cons (module-obarray (current-module)))

(module-map (λ (sym var) sym) (resolve-interface '(guile)))
(module-map (λ (sym var) sym) (resolve-interface '(opencog)))
(module-map (λ (sym var) sym) (resolve-interface '(opencog learn)))

who is using a module?
(module-uses (resolve-module '(guile-user)))

>>>> excellent for modules!
http://git.net/ml/guile-user-gnu/2016-06/msg00040.html

101000   26627  256 11.9 15129736 11795708 pts/6 Sl+ 18:41 516:33 guile
-l pair-count-yue.scm


not being split: FIXED.
fix is
$text =~ s/([\.?!]) *(\p{InCJK})/$1\n$2/g;

呢度啲路順序係從南去到北嚟排列嘅，其中加粗咗嘅字係主幹道：美華北路.新河浦二橫路.新河浦五橫路.新慶路.煙墩路、寺右新馬路.寺貝通津.共和大街.松崗東.共和西路.中山一路.

2012年，《向前走向愛走》.第四十五屆金鐘獎個人獎戲劇節目女主角獎.郭采潔官方網站.


No database persistant storage configured! Use the STORAGE config
keyword to define.

Java gets slower and slower

-------------------------

(use-modules (opencog) (opencog cogserver))
(start-cogserver "cogserver.conf")

(define (inc atom) (cog-set-tv! atom (cog-new-ctv 0 0 (+ 1 (tv-count (cog-tv atom))))))

(define foo (Concept "foo"))
(define (loo) (inc foo) (loo))

Hmmm
(gc-stats)
((gc-time-taken . 9229154858) (heap-size . 14364672) (heap-free-size . 987136)
(heap-total-allocated . 965473792) (heap-allocated-since-gc . 4150752)
(protected-objects . 7) (gc-times . 382))

(ConceptNode "foo" (ctv 0 0 1297544))

---------

(gc-stats)
((gc-time-taken . 36662444393) (heap-size . 27287552) (heap-free-size . 2043904)
(heap-total-allocated . 6769590208) (heap-allocated-since-gc . 12259216)
(protected-objects . 7) (gc-times . 1011))

(ConceptNode "foo" (ctv 0 0 25027699))

---------

gc-stats)
((gc-time-taken . 61656366381) (heap-size . 53968896) (heap-free-size . 18456576)
(heap-total-allocated . 13686988416) (heap-allocated-since-gc . 5711392)
(protected-objects . 7) (gc-times . 1240))

(ConceptNode "foo" (ctv 0 0 38117275))

-------
Hmm looks like we are leaking tv's ... oh wait.. does it stop?

(gc-stats)
((gc-time-taken . 105993964481) (heap-size . 72843264) (heap-free-size . 29458432)
(heap-total-allocated . 27893224720) (heap-allocated-since-gc . 9728)
(protected-objects . 7) (gc-times . 1591))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 79863947))

Nope ... just a temporary pause, while the free size is whittled down.

(gc-stats)
((gc-time-taken . 114596558158) (heap-size . 89620480) (heap-free-size . 33521664)
(heap-total-allocated . 30637347648) (heap-allocated-since-gc . 7308304)
(protected-objects . 7) (gc-times . 1654))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 87085578))

But I don't get it .. just one byte per tv ???

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 2603 linas     20   0  981064 160664  30904 R 123.1  0.2  17:28.70 guile       
 2603 linas     20   0  998888 178524  30904 R 123.7  0.2  25:52.19 guile       
 2603 linas     20   0  998888 178580  30904 R 128.7  0.2  40:07.75 guile       
 2603 linas     20   0 1038496 217948  30904 R 131.9  0.2  46:48.42 guile       
 2603 linas     20   0 1040744 220368  30904 R 125.2  0.2  51:08.05 guile       
 2603 linas     20   0 1040876 220276  30904 R 120.1  0.2  83:44.38 guile       
 2603 linas     20   0 1117852 297744  31132 R 118.1  0.3 172:51.42 guile       




----------
 2603 linas     20   0  998888 178524  30904 R 123.7  0.2  25:52.19 guile
Even less than that:
(gc-stats)
((gc-time-taken . 172622614398) (heap-size . 89620480) (heap-free-size . 36347904)
(heap-total-allocated . 48279193696) (heap-allocated-since-gc . 4224)
(protected-objects . 7) (gc-times . 2002))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 1.3901905e+08))

-------------
 2603 linas     20   0  998888 178580  30904 R 128.7  0.2  40:07.75 guile
(gc-stats)
((gc-time-taken . 217265746382) (heap-size . 106405888) (heap-free-size . 4673536)
(heap-total-allocated . 61824766864) (heap-allocated-since-gc . 59720592)
(protected-objects . 7) (gc-times . 2265))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 1.7490337e+08))
--------------
2603 linas     20   0 1038496 217948  30904 R 131.9  0.2 46:48.42 guile
(gc-stats)
((gc-time-taken . 415346915596) (heap-size . 139968512) (heap-free-size . 36679680)
(heap-total-allocated . 125921049232) (heap-allocated-since-gc . 26342512)
(protected-objects . 7) (gc-times . 3325))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 3.5583169e+08))
-------------
 2603 linas     20   0 1040876 220276  30904 R 120.1  0.2  83:44.38 guile       
(gc-stats)
((gc-time-taken . 711424805684) (heap-size . 139968512) (heap-free-size . 11227136)
(heap-total-allocated . 225609862112) (heap-allocated-since-gc . 66243952)
(protected-objects . 7) (gc-times . 4683))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 6.3894746e+08))

----------------
 2603 linas     20   0 1117848 297520  30904 R 118.8  0.3  97:20.18 guile       
(gc-stats)
((gc-time-taken . 823234806093) (heap-size . 207081472) (heap-free-size . 70197248)
(heap-total-allocated . 263246315808) (heap-allocated-since-gc . 75918272)
(protected-objects . 7) (gc-times . 5155))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 7.4406271e+08))

---------------------
 2603 linas     20   0 1117852 297744  31132 R 118.1  0.3 172:51.42 guile       
(gc-stats)
((gc-time-taken . 1445970832414) (heap-size . 207081472) (heap-free-size .
63324160) (heap-total-allocated . 471514682464) (heap-allocated-since-gc . 6332752)
(protected-objects . 7) (gc-times . 7211))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 1.3366125e+09))




=========================

replace call to scm_gc_register_collectable_memory by call to 
scm_gc_register_allocation(size)


whoa --- 
GC Warning: Repeated allocation of very large block (appr. size 27369472):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size 28766208):
        May lead to memory leak and poor performance.
Loaded 280000 atoms.
GC Warning: Repeated allocation of very large block (appr. size 28766208):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size 28766208):
        May lead to memory leak and poor performance.
        Loaded 270000 atoms.
GC Warning: Repeated allocation of very large block (appr. size 28766208):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size 14385152):
        May lead to memory leak and poor performance.
        Loaded 260000 atoms.

================================

fresh, guile-2.0
 (gc-stats)
$6 = ((gc-time-taken . 114568428) (heap-size . 14409728) (heap-free-size .
2711552) (heap-total-allocated . 18881904) (heap-allocated-since-gc .
1054528) (protected-objects . 137) (gc-times . 14))

after half-minute:
(gc-stats)
((gc-time-taken . 7534031063) (heap-size . 19734528) (heap-free-size
. 5259264) (heap-total-allocated . 939889168) (heap-allocated-since-gc .
1657120) (protected-objects . 143) (gc-times . 326))
guile> foo
(ConceptNode "foo" (ctv 0 0 2520410))

 6861 101000    20   0  735404  42952  16680 R 109.9  0.0  14:33.40 guile       
 6861 101000    20   0  735404  42952  16680 R 114.5  0.0  44:35.68 guile       


(gc-stats)
((gc-time-taken . 148069551756) (heap-size . 19734528) (heap-free-size .
2740224) (heap-total-allocated . 28219212944) (heap-allocated-since-gc .
790384) (protected-objects . 143) (gc-times . 4930))
guile> foo
(ConceptNode "foo" (ctv 0 0 54310643))


replace call to scm_gc_register_collectable_memory by call to
scm_gc_register_allocation(size)


   static std::atomic<size_t> _tv_pend_cnt;
   static std::atomic<size_t> _tv_total_cnt;
   static std::atomic<size_t> _tv_pend_sz;
   static std::atomic<size_t> _tv_total_sz;


(define (inc atom) (cog-set-tv! atom (cog-new-ctv 0 0 (+ 1 (tv-count (cog-tv
atom))))))
scheme@(guile-user)> 
scheme@(guile-user)> (define foo (Concept "foo"))
scheme@(guile-user)> (define (loo) (inc foo) (loo))
scheme@(guile-user)> (loo)
duuude its pend cnt=11425 (274200) tot=1400000 (33600000)
duuude its pend cnt=14379 (345096) tot=1500000 (36000000)
duuude its pend cnt=15600 (374400) tot=2200000 (52800000)

duuude its pend cnt=8047 (193128) tot=48300000 (1159200000)
duuude its pend cnt=1230 (29520) tot=49300000 (1183200000)
duuude its pend cnt=12432 (298368) tot=49400000 (1185600000)
duuude its pend cnt=19857 (476568) tot=50000000 (1200000000)
(gc-stats)
((gc-time-taken . 54370538078) (heap-size . 10948608) (heap-free-size . 1925120)
(heap-total-allocated . 8532174704) (heap-allocated-since-gc . 10336)
(protected-objects . 7) (gc-times . 2051))
guile-yue> foo
(ConceptNode "foo" (ctv 0 0 26737610))
 4617 linas     20   0  847596  50284  27072 R 133.2  0.1   5:26.89 guile       

(ConceptNode "foo" (ctv 0 0 46416463))
duuude its pend cnt=20565 (493560) tot=94300000 (2263200000)

so -- 46M incrs but 94M take-tvs -- so two takes for each incr.
-- one to get the value, one to set the value.


 4617 linas     20   0  847584  50612  27156 R 135.2  0.1  23:46.94 guile       

(define (rate)
(define shu (Concept "shu"))
(define cnt 0)
(define start (- (current-time) 0.1))
(define (finc atom) 
	(if (eq? 0 (modulo cnt 100000))
		(begin (display "rate=")
		(display (/ cnt (- (current-time) start))) (newline)))
	(set! cnt (+ cnt 1))
	(cog-set-tv! atom (cog-new-ctv 0 0 (+ 1 (tv-count (cog-tv atom))))))

(define (floo) (finc shu) (floo))
(floo)
)

(define (inc atom) (cog-set-tv! atom (cog-new-ctv 0 0 (+ 1 (tv-count (cog-tv atom))))))

(define foo (Concept "foo"))
(define (loo) (inc foo) (loo))

(statprof-stop)
(statprof-display)


with the atomics: rate == about 145.5K/sec
without the atomics: about 103.2K/sec !!
again with atomics: rate == 125K/sec !! wtf .. why not as high as before?
stop restart, rate=130K ...
stop restart - rate= 107K ... wtf
stop, restart = 109K
stop restart = 107K   glargle
again --- without atomics:
rate = 147K   dafuq
stop restart = 151K
stop restart = 79K   crazy shit
stop restart = 141K  this is so not making sense, except as a
crazy cache-line issue.


clean start: without atomics
(gc-stats)
((gc-time-taken . 845338507) (heap-size . 5963776) (heap-free-size . 421888)
(heap-total-allocated . 73153424) (heap-allocated-since-gc . 902704)
(protected-objects . 7) (gc-times . 65))

(gc-stats)
((gc-time-taken . 605534396784) (heap-size . 6025216) (heap-free-size . 356352)
(heap-total-allocated . 29673578224) (heap-allocated-since-gc . 361904)
(protected-objects . 7) (gc-times . 32428))

no growth at all.


OK, so ... a leak in sql?
a leak in TLB!! ... no because that doesn't explain guile heap...
unless guile heap is confused...

on startup:
(gc-stats)
$1 = ((gc-time-taken . 170774772) (heap-size . 15364096) (heap-free-size .
3166208) (heap-total-allocated . 18421440) (heap-allocated-since-gc .
770768) (protected-objects . 149) (gc-times . 15))

 wtf .. why no printing?


_tv_pend_cnt++;
_tv_pend_sz += sizeof(*tv);

// _tv_total_cnt++;
_tv_total_sz += sizeof(*tv);

if (0 == ((size_t) (_tv_total_cnt.fetch_add(1))) % 100000) {
printf("duuude its pend cnt=%lu (%lu) tot=%lu (%lu)\n",
(size_t) _tv_pend_cnt, (size_t) _tv_pend_sz, (size_t) _tv_total_cnt,
(size_t) _tv_total_sz);
logger().info("duuude its pend cnt=%lu (%lu) tot=%lu (%lu)",
(size_t) _tv_pend_cnt, (size_t) _tv_pend_sz, (size_t) _tv_total_cnt,
(size_t) _tv_total_sz);
}


OK, so its not the TV ... (not the TV in guile gc)

So maybe its prim environ?? Nooo not that either
Maybe handles?? (in guile) no its not that. (not in guile gc)

 well, its not the TLB...
and not the atoms ... TLB has 400K entries, with 18MB of pairs
atoms allocated are 466286 for 63414896 = 63MBytes but guile is
1.6GB resident, 9.3GB virt.... wtf...

each atom is 136 MB ex tv.

2.9 gb resident, but 1.6M atoms for 215MB size, and 64MB of tlb contents
what about atomspace?  only 19922 atoms in atomspace...
heap size is 2GB ... 

Maybe stub out capture-stack? it was the cuplrit before...
Nope seems to make no difference.

are we leaking SCM values somwhere?  How?

misc_to_string ?  no, code audit.
scm_to_utf8_string   no, code audit...

--------------------------------------------------------------
try guile-2.2 from git
Great. that seg-faults... maybe some other version doesn't ...
try 2.1.5 ? 2.1.4 ?   No, because even though it segfaulted
it did seem to also grow.

Seg-faults twice in a row, within 10 minutes wall-clock time
(about 36 mins cpu time).

---------------------------------------------------------------

Try below. ... It does not leak.

(use-modules (opencog) (opencog cogserver))
(start-cogserver)

(define (slu)
(define cnt 0)
(define start (- (current-time) 0.1))
(define (mka) 
	(if (eq? 0 (modulo cnt 100000))
		(begin (display "rate=")
		(display (/ cnt (- (current-time) start))) (newline)
		(cog-map-type (lambda (ato) (cog-extract ato) #f) 'ListLink)
		(cog-map-type (lambda (ato) (cog-extract ato) #f) 'ConceptNode)
	))
	(set! cnt (+ cnt 1))
	(ListLink
		(ConceptNode (string-append "concepto " (number->string cnt )))
		(ConceptNode (string-append "glorg " (number->string cnt )))))

(define (aloo) (mka) (aloo))
(aloo)
)

(count-all)
(cog-report-counts)

(gc-stats)
((gc-time-taken . 6660684289) (heap-size . 15646720) (heap-free-size . 3055616)
(heap-total-allocated . 861940880) (heap-allocated-since-gc . 5203440)
(protected-objects . 7) (gc-times . 298))

((gc-time-taken . 15414762477) (heap-size . 16101376) (heap-free-size . 2859008)
(heap-total-allocated . 2665977008) (heap-allocated-since-gc . 5064624)
(protected-objects . 7) (gc-times . 562))

rate=47.3K  (concept only)
rate=15.7K (listlinks+concepts)

---------------------------------------------------------------

/tmp/bang.sh
#!/bin/bash

i=0
while true ; do
  let i=$i+1
  if [ "$(($i % 2000))" -eq "0" ] ; then
    echo loop $i
  fi
  echo '(display ctr)' | nc localhost 17001
  # echo '(NumberNode ctr)' | nc 10.0.3.239 17001
  # echo '(NumberNode' $i ')' | nc 10.0.3.239 17001
  # echo '(NumberNode 42)' | nc localhost 17001
echo '(ConceptNode "fooo ' $i $$ ' you too")' | nc localhost 17001 >> /dev/null

done

run 10 copies of above.
--- no leak   ... and no crash...  so this is very stable. wtf.

---------------------------------------------------------------
OK, so lets try the full pipeline.
but without updates

Whoops. Its blowing up

((gc-time-taken . 8772615322) (heap-size . 820801536) (heap-free-size . 90624000)
(heap-total-allocated . 6508583904) (heap-allocated-since-gc . 84464688)
(protected-objects . 313) (gc-times . 210))

((gc-time-taken . 8772615322) (heap-size . 1179750400) (heap-free-size . 27713536)
(heap-total-allocated . 16069320928) (heap-allocated-since-gc . 339494096)
(protected-objects . 313) (gc-times . 255))


what if we just do one article over and over?
./ss-one.sh yue beta-pages/A-Z/Zyu4 localhost 17006

It blows up.

what if we do one sentence over and over?
(observe-text "係 拉 丁 字 母 同 阿 剌 伯 數 字 串 字")

run it once, goes from (heap-size . 5963776)  to (heap-size . 20996096)
run 10 times: (heap-size . 28332032) 
It still blows up....

without bang.sh

(define (lo)
(define cnt 0)
(define start (- (current-time) 0.1))
(define (mke) 
	(if (eq? 0 (modulo cnt 20))
		(begin (display "rate=")
		(display (/ cnt (- (current-time) start))) (newline)
	))
	(set! cnt (+ cnt 1))
	(observe-text "係 拉 丁 字 母 同 阿 剌 伯 數 字 串 字")
)

(define (aloo) (mke) (aloo))
(aloo)
)

Above is .. wow its stable :
(heap-size . 21184512) (gc-times . 70)
(heap-size . 40243200) (gc-times . 242)
(heap-size . 40243200) (gc-times . 1458)  14:19.43 cpu
(heap-size . 40243200) (gc-times . 2554)  23:48.49 guile 

ssooo .. its something thread-related.  But just having netcat did not do the
trick. ... using java on one thread doesn't trigger it.  Using observe-text
does not trigger it. (ie. relex-parse, etc from one thread.)

do we have zombie threads?

(define x (call-with-new-thread (lambda () (observe-text " 係 拉 丁 字 母 同 阿 剌
伯 數 字 串 字"))))

(define (th)
(define cnt 0)
(define start (- (current-time) 0.1))
(define (thu v) (call-with-new-thread (lambda () 
	(observe-text " 係 拉 丁 字 母 同 阿 剌 伯 數 字 串 字"))))

(define lst (list 1 2 3 4 5 6 7 8 9 0))
(define lst (make-list 10 42))

(define (mke) 
	(define thl (map thu lst))
	(length (all-threads))
	(map join-thread thl)

	(set! cnt (+ cnt 1))
	(display "rate=")
	(display (/ cnt (- (current-time) start))) (newline)
)

(define (aloo) (mke) (aloo))
(aloo)
)

Hmmm ... above is blowing up!  but also .. its not actually threading,
(the atoms stuff is not happening out of order...)
either.   Oh, but it is blowing up ....

(heap-size . 87683072) (gc-times . 4295)
(heap-size . 104460288) (gc-times . 4513)
(heap-size . 255717376) (gc-times . 4884)

OK, full production system with the new guile:
(heap-size . 481013760) (gc-times . 301)
(heap-size . 755843072) (gc-times . 402) 11 minutes CPU
(heap-size . 797286400) (gc-times . 530) 15 mins cpu
(heap-size . 1285570560) (gc-times . 1713) 100 mins CPU
(heap-size . 1546678272) (gc-times . 2251) 140 mins CPU 

but is this really new? It was recompiled, but the version number is
wrong...

Again, full prduction: with guile -v
guile (GNU Guile) 2.1.5.19-7e9395 (8 Jan 2017)

(heap-size . 652918784) (gc-times . 233) ; about 8 mins CPU
(heap-size . 737722368) (gc-times . 339) ; 12 mins CPU
(heap-size . 1332973568) (gc-times . 1797) ; 120 mins CPU
(heap-size . 1441443840) (gc-times . 2221) ; 151 min CPU
(heap-size . 1521213440) (gc-times . 2441) ; 168 min cpu
(heap-size . 1595101184) (gc-times . 3061) ; 218 min cpu
(heap-size . 1726119936) (gc-times . 3292) ; 237 min
(heap-size . 1960865792) (gc-times . 6698) ; 510 minn
(heap-size . 1960865792) (gc-times . 10383) ; 805 min
(heap-size . 2931556352) (gc-times . 14211) ; 1199 min
(heap-size . 3302985728) (gc-times . 23278) ; 2186

 
Much improved: an earlier result was:
(heap-size . 4601581568) (gc-times . 485) ; almost 5GB!



===========================================

Non-openccog test case showing problem: bug 
https://debbugs.gnu.org/cgi/bugreport.cgi?bug=25386

(define junk 0)
(define halt #f)

(define (wtf-thr)
	(define start (- (current-time) 0.1))

	; Create thread that does junk and exits.  Yes, the increment
	; of `junk` is not protected, and its racey, but so what.
	(define (mkthr v) (call-with-new-thread (lambda () (set! junk (+ junk 1)))))

	; thread arguments
	(define thrarg (make-list 10 0))

	(define cnt 0)
	(define (mke) 
		; Create a limited number of threads
		(define thr-list (map mkthr thrarg))
		; (display (length (all-threads)))
		(map join-thread thr-list)

		; Some handy debug printing.
		(set! cnt (+ cnt 1))
		(if (eq? 0 (modulo cnt 500))
			(begin
				(display "rate=")
				(display (/ cnt (- (current-time) start))) (newline)
            (display "num threads=")
            (display (length (all-threads))) (newline)
            (display (gc-stats)) (newline) (newline)
			)))

	; tail recursive infinite loop.
	(define (aloop) (mke) (if (not halt) (aloop)))

	; while forever.
	(aloop)
)

(call-with-new-thread wtf-thr)
(set! halt #t)

Gahh seg-faults too

Thread 1 "guile" received signal SIGSEGV, Segmentation fault.
thread_mark (addr=0x55556a3f9e00, mark_stack_ptr=<optimized out>, 
    mark_stack_limit=0x7fffffffd350, env=<optimized out>)
    at ../../libguile/threads.c:111
warning: Source file is more recent than executable.
111	/* No threads; we can just use GC_stackbottom.  */
(gdb) bt
#0  thread_mark (addr=0x55556a3f9e00, mark_stack_ptr=<optimized out>, 
    mark_stack_limit=0x7fffffffd350, env=<optimized out>)
    at ../../libguile/threads.c:111

bug-guile@gnu.org 

https://debbugs.gnu.org/cgi/bugreport.cgi?bug=25386

----------------------------------------------------


(heap-size . 5939200)  (gc-times . 70)
(heap-size . 45510656) (gc-times . 147)
(heap-size . 399896576) (gc-times . 1018)

(hash-map->list cons (module-obarray (current-module)))

(heap-size . 183734272)  with gc inside the thread ... (gc-times . 402007)
(heap-size . 183734272) (gc-times . 976989)
(heap-size . 183734272) (gc-times . 1869962)
(heap-size . 183734272) (gc-times . 8526663)

stochastic gc: 
(heap-size . 369917952) (gc-times . 40387)
(heap-size . 428638208) (gc-times . 511116)
(heap-size . 428638208) (gc-times . 1218770)
(heap-size . 428638208) (gc-times . 6515758)

every-17th gc:
(heap-size . 1875902464) (gc-times . 290105)
(heap-size . 2068840448) (gc-times . 2605562) -- 44325000 threads

every 10th-gc in main loop, not in thread:
(heap-size . 544063488) (gc-times . 113)
(heap-size . 5151375360) (gc-times . 1113)
(heap-size . 8322269184) (gc-times . 2113)
Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS

gc must be done at thread-exit, for this plan to work!

size=120MB+90MB * n

(define mtx (make-mutex))

   (define (mkthr v) (call-with-new-thread (lambda ()
                (lock-mutex mtx)
                (if (eq? 0 (modulo junk 17)) (gc))
                (set! junk (+ junk 1))
                (unlock-mutex mtx)
                )))


--------
OK new guile-2.2 doesn't blow up any more:

(heap-size . 7921664) (gc-times . 40)
(heap-size . 14344192) (gc-times . 953)
(heap-size . 14344192) (gc-times . 5219)  ; after 4 minutes CPU
(heap-size . 26419200) (gc-times . 64975) ; after 77 minutes CPU
(heap-size . 26419200) (gc-times . 133346) ; after 154 mins CPU
(heap-size . 26419200) (gc-times . 170083) ; after 192 mins CPU
(heap-size . 26419200) (gc-times . 249102) ; after 283 mins cpu
(heap-size . 26419200) (gc-times . 420031) ; after 468 min cpu
(heap-size . 26419200) (gc-times . 557039) ; after 804 mins CPU

alt version: 510 threads:
(heap-size . 10604544) (gc-times . 32)
(heap-size . 19505152) (gc-times . 484)
(heap-size . 35926016) (gc-times . 1761)
(heap-size . 48238592) (gc-times . 4217)  ; after 8 minutes cpu time
(heap-size . 48238592) (gc-times . 47902) ; after 76 mins CPU
(heap-size . 48238592) (gc-times . 73063) ; after 114 mins CPU
(heap-size . 65540096) (gc-times . 128094) ; after 209 mins cpu
(heap-size . 65540096) (gc-times . 248321) ; after 399 mins
(heap-size . 65540096) (gc-times . 344197) ; after 546 min

dffe495d0de1466f62a91a6d74cc0f388e0f4f3f
* libguile/threads.c (on_thread_exit): Lessen excess retention.
12eb7b8256f579fab60ebe0b38eb8788c1276eb8

scm_i_vm_free_stack 

=================================================================
Also 25387

https://debbugs.gnu.org/cgi/bugreport.cgi?bug=25387



===================================================================

(make-dynamic-state (current-dynamic-state))

(define (ds)
	(define cnt 0)
	(define start (- (current-time) 0.1))

	(define (mke) 
		(define x (make-dynamic-state (current-dynamic-state)))
	
		(set! cnt (+ cnt 1))
		(if (eq? 0 (modulo cnt 1000000))
			(begin
				(display "iter=") (display cnt) (newline)
				(display "rate=")
				(display (/ cnt (- (current-time) start))) (newline)
			)))

	(define (aloo) (mke) (aloo))
	(aloo)
)

Above looks just fine.


(count-all)
(cog-report-counts)
(cog-prt-atomspace)
(length (all-threads))
(gc-stats)

====================================================================
Bug -- split needs to put whitespace around parent, before/after commas,
etc. and begin-end quotes  FIXED

====================================================================
Bugg- the utf8 is fucked up.   Fixed. Its a guile-2.1.5 regression
its ok in the containers ... select * from atoms where type=110;
(cog-get-atoms 'WordInstanceNode)

but guile-2.2 fucks up. 
(string-append "a" "係" "c") is OK.
(Concept "係") is broken
scm_c_eval_string
scm_print_state
scm_puts now does scm_c_put_latin1_chars fuuuuuck,.

scm_lfwrite (s, strlen (s), port); --- again with latin1
scm_c_put_string
arggg
bug-guile@gnu.org  --  bug#25397:
https://debbugs.gnu.org/cgi/bugreport.cgi?bug=25387  
GUILE_VERSION_MINOR 1


====================================================================

call-with-new-thread
threads.c

  data = scm_gc_typed_calloc (launch_data);
  err = scm_i_pthread_create (&id, NULL, launch_thread, data);


scm_i_pthread_detach (scm_i_pthread_self ());
pthread-threads.h:#define scm_i_pthread_detach                pthread_detach
#define scm_i_pthread_self                  pthread_self


join_thread_var  libguile/threads.x  uh no 


(with-continuation-barrier
(set! (thread-join-data thread) (cons cv mutex))

scm_i_with_guile calls ...
	GC_call_with_stack_base  which is from boehm
	calls with_guile
		calls scm_i_init_thread_for_guile calls scm_i_init_guile
		scm_c_with_continuation_barrier

scm_current_dynamic_state ()   -- save_dynamic_state  ? maybe not freed?

what is in the currrent dynamic state?

everything looks kosher.  best guess: copy of dyanmic state is not being gc'ed.
SCM_USE_PTHREAD_THREADS ?? defined ?? yes.
build/libguile/scmconfig.h:#define SCM_USE_PTHREAD_THREADS 1 

GC_register_my_thread

on_thread_exit ??? thread_count--; seems to be called because throead count 
is correct ... who sets scm_i_thread_key ? .. guile init does.


---------------------------------------------------------------
Ongoing failure:
If I gc after every thread, then hit this:

guile: hashtab.c:137: vacuum_weak_hash_table: Assertion `removed <= len'
failed.
Aborted

2x... once after a minute
3x ...

try 2.0.13
autoconf flex gettext libunistring-dev libffi-dev texinfo

apt-get purge guile-2.0 guile-2.0-libs

---------------------------------------------------------------
Bug --- java fucks up like this:
above: java is runnning at 900% so its getting stuff in paralel.
It seems to be responding slowly, though ... and guile is not running
at high cpu .. its under 100% wtf... ah haha -- java is spinning 
on socket wait in some way...

Its messed up. Java is buggy.
------------------------------------------------------------------

Bug --- java always gives back exactly the same ... is the rand
num generator being reset each time??? I think it is, for
reproducibility?  No .. it was a bug. Fixed. pull req #471 in LG

for morphemes, anysplit.c always sets seed=0 every call.


anysplit.c:
rng_uniform 
sample_point
use_sampling 

api.c:				(rand_r(&sent->rand_state) %
parse_options_set_repeatable_rand

struct anysplit_params * anysplit;
 set by 

duuuude wtf 0 3b23e1b0 240 st=1840299789
duuuude wtf 1 78520aa1 33 st=-895367152
duuuude wtf 2 6372c222 322 st=1780636463
duuuude wtf 3 5c322e38 312 st=-231201766
duuuude wtf 4 303c3bea 146 st=-1008023999
duuuude wtf 5 2a463357 233 st=-480833580

      Linkage lkg = &sent->lnkages[in];
      Linkage_info *lifo = &lkg->lifo;
iindex
sentence_parse

63  70 248 277 -- birthday paradox



------------------------------------
LG:   FIXED, will be in version 5.3.14  -- LG pull req #470
any is ignoring the last word
no its not, its just not displaying it. so its a minor bug.
linkage_print_diagram

l->r pass removed 1
LEFT-WALL[1] 港[2] 區[2] 全[2] 國[2] 人[2] 

utf8_strlen


------------------------

BUGGGGGGGGGGG -- delete everything fails, cause  still counting in the other
threads!! Aieee! ... 

its also probably picking up the wrong sentence...

use .. parse-get-relex-outputs ? Uh no

(define foo
	(let ((mtx (make-mutex)))
		(lambda ()
			(display mtx) (newline)
			(format #t "duude is locked? ~A\n" (mutex-locked? mtx))
			(format #t "duude owner ~A\n" (mutex-owner mtx))
			(format #t "duude try ~A\n" (try-mutex mtx))
	))
)

(use-modules (opencog))

(AnchorNode "foo")
(ListLink (AnchorNode "foo") (Concept "a"))
(ListLink (AnchorNode "foo") (Concept "b"))
(ListLink (AnchorNode "foo") (Concept "c"))

(SentenceSequenceLink
(WordSequenceLink
(cog-extract-recursive sent)


Delete (SentenceSequenceLink (sent numbernode))
(use-modules (ice-9 receive) (srfi srfi-1) (opencog) (opencog
atom-types))

(use-modules (opencog) (opencog persist) (opencog persist-sql))
(use-modules (opencog nlp learn))
(sql-open "opencog_test" "opencog_tester" "cheese")
(observe-text "this is a foo")


psql -h localhost -U opencog_tester opencog_test


PACKAGE_VERSION
config.h:#define PACKAGE_VERSION "2.1.5.19-7e9395"

Seem to have 

libgc-dev

dpkg -l libgc1c2
Desired=Unknown/Install/Remove/Purge/Hold
|
Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name           Version      Architecture Description
+++-==============-============-============-=================================
ii  libgc1c2:amd64 1:7.4.2-8    amd64        conservative garbage
collector fo

---------------------------------------------------------------

        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
21573632):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
43147264):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
9056256):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
43147264):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
43147264):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
86290432):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
7438336):
        May lead to memory leak and poor performance.
GC Warning: Repeated allocation of very large block (appr. size
9588736):
        May lead to memory leak and poor performance.


In conclusion:

(gc-stats)
Entering scheme shell; use ^D or a single . on a line by itself to exit.
guile-yue> ((gc-time-taken . 7077498787602) (heap-size . 15487754240)
(heap-free-size . 3580190720) (heap-total-allocated . 900893846432)
(heap-allocated-since-gc . 6264284448) (protected-objects . 288)
(gc-times . 1059))

15.5GB in total, 3.6GB free

guile-yue> (gc)

guile-yue> (gc-stats)
((gc-time-taken . 7122988472428) (heap-size . 15487754240)
(heap-free-size . 8725934080) (heap-total-allocated . 900895104976)
(heap-allocated-since-gc . 1142496) (protected-objects . 288) (gc-times
. 1060))

Now its 8.7GB free, leaving 7GB in use.

guile-yue> (cog-report-counts)
((ListLink . 331150) (EvaluationLink . 331150) (AnchorNode . 1)
(WordNode . 10720) (LinkGrammarRelationshipNode . 1) (LgConnectorNode .
1) (LgConnMultiNode . 1) (LgConnDirNode . 2) (LgConnector . 4) (LgAnd .
4))

guile-yue> (count-all)
673034

So why is guile so splurgy?  This is just not that many atoms ... 
is bdwgc too conservative, somehow finding the TLB stuff?
what If I close out the TLB, does guile free it all?

1244:00 start of sql-close cpu time at start
1244:36 at stop -- so about 40 cpu-sconds, OK.

((gc-time-taken . 7128743570856) (heap-size . 15487754240)
(heap-free-size . 14163222528) (heap-total-allocated . 900991577328)
(heap-allocated-since-gc . 172640) (protected-objects . 288) (gc-times .
1061))

whoa -- that was it:
fre is now 14.2 out of 15.5GB so actual use is only 1.3GB 
... for 673K atoms, so about 2KBytes/atom which is still a lot, but 
... plausible.

So bdwgc was confused about the TLB... how? why? what about atom
creation that leaves around this handle-confusion?

before sql close:

ubuntu    4335  217 29.4 32768196 29150768 pts/6 Sl+ Jan11 1243:04 guile -l pair-count-yue.scm

after:
ubuntu    4335  210 28.9 32164608 28616384 pts/6 Sl+ Jan11 1244:45 guile -l pair-count-yue.scm

so no shrinkage directly....

(cog-map-type (lambda (ato) (cog-extract-recursive ato) #f) 'WordNode)
(gc)
.. fails to shrink the heap!

stop the cogserver ... (gc) still no shrinkage


void fn (char*, GC_word)

GC_set_warn_proc (fn)
https://www.hboehm.info/gc/gcinterface.html

GC_warn_proc GC_set_warn_proc(GC_warn_proc p)

libcord
libgc.so -> libgc.so.1.0.3

GC_current_warn_proc
GC_default_warn_proc
WARN


select count(*) from atoms;
1480054
1522104

        6: ??:0 GC_alloc_large()
        7: ??:0 GC_generic_malloc()
        8: ??:0 GC_core_malloc_atomic()
        9: strings.c:165        make_wide_stringbuf()
        10: strings.c:331       scm_i_make_wide_string()
        11: strings.c:1165      scm_string()
        12: vm-engine.c:763     vm_debug_engine()

SCM_STRING_LENGTH_HISTOGRAM
%stringbuf-hist

        6: ??:0 GC_alloc_large()
        7: ??:0 GC_generic_malloc()
        8: weak-table.c:362     allocate_entries()
        9: weak-table.c:432     is_acceptable_size_index()
        10: weak-table.c:677    weak_table_put_x()
        11: weak-table.c:893    scm_c_weak_table_put_x()
        12: read.c:423  maybe_annotate_source()
        13: gc.h:182    maybe_annotate_source()
        14: read.c:725  scm_read_string()
        15: read.c:476  scm_read_sexp()
        16: read.c:1814 read_inner_expression()
        17: read.c:476  scm_read_sexp()
        18: read.c:1814 read_inner_expression()
        19: read.c:1964 scm_read()
        20: vm-engine.c:763     vm_debug_engine()

scm_sys_string_dump
scm_sys_symbol_dump

scm_ilength

#define SCM_CHAR(x) ((scm_t_wchar)SCM_ITAG8_DATA(x))


Ah hah ... very long strings are ... very long strings
from java.


---------------------------------------------------------------


local_id_cache
add_id_to_cache
get_ids

maybe_create_id
id_create_cache

WordInstanceNode
LgLinkInstanceNode
  119 | WordInstanceNode
  120 | WordInstanceLink

  159 | LgLinkInstanceNode
  160 | LgLinkInstanceLink

how are these getting in the TLB???

SQLBackingStore::getLink(Handle& h) const
{

AtomSpace::fetch_atom
persist/guile/PersistSCM.cc

fetch-atom
fetch-incoming-set

is id deadlocking on the resolve? 

t1
delete
get table lock
rele table lock
  now t2 gets the table lock.
get tlb lock  << maybe halt here?
<<<< safe because nothing inside, so forward progress...
relese tlb lock
get table lock. << maybe halt here?


t2
add
table lock 1
tlb lock
do_res
table lock  2
<<< should wordwar prgress cause in ssame thread.

argh 201 theads
 201 -- do_poll_result SchemeEval.cc:655
 200 -- join from eval_loop GenericShell.cc:457
 197 -- getNodeHandle AtomTable.cc:255 
        owenr 20950 whih is 44
  44 -- TLB::removeAtom TLB.cc:143
        owner is 21423 which is 179
 179 -- AtomTable::getNodeHandl AtomTable.cc:255
        owner is 20950 which is 44

 so TLB can't get lock cause its held by 179 

but 179 is holding lock and calling do_res while holding the
atomspace lock. called by tlb::add atom

solutions(s): TLB must drop lock while doing do_res
atomtable must fully unwindws recursive lock


so who in 44 has it?
AtomTable.cc:841 is hwere we are ... 
called at line 762 with lock held at line 729  so we are at least
one-deep. maybe more??

std::unique_lock<std::recursive_mutex> 

    double frac = 100.0 * extra / ((double) all.size());
    printf("sql-stats: Examined %lu atoms in atomspace; %lu extra in TLB
(%f percent) \n", 
        all.size(), extra, frac);


    double frac = 100.0 * extra / ((double) all.size());
    printf("sql-stats: Found %lu atoms in atomspace; %lu extra in TLB
(%f percent) \n",
        all.size(), extra, frac);
frac = 100.0 * extra / ((double) _store->_tlbuf.size());
    printf("sql-stats: tlbuf size=%lu extra=%f percent\n",
_store->_tlbuf.size(), 
frac);
}




the __data.__owner member of the pthread_mutex_t 
print mutex.__data.__owner

---------------------------------------------------------------

(near-startup)
sql-stats: Atomspace holds 55484 atoms
sql-stats: tlbuf holds 19928 atoms
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 2031 unremapped atoms (6.600585 pct)
sql-stats: 211017858 of 211020413 uuids unused (99.998789 pct)

Gaaaaackk .. this implies that 99.999 percent of calls to sql
are wasted ! well, actually not, since the cache should stop
the bad acting.

sql-stats: Atomspace holds 420064 atoms
sql-stats: tlbuf holds 154316 atoms
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 16398 unremapped atoms (6.627275 pct)
sql-stats: 211339442 of 211467072 uuids unused (99.939645 pct)

sql-stats: Atomspace holds 86550 atoms
sql-stats: tlbuf holds 80674 atoms
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 59344 unremapped atoms (72.948089 pct)
sql-stats: 212784068 of 212861833 uuids unused (99.963467 pct)


====================================================
clean start:

sql-stats: Atomspace holds 13949 atoms
sql-stats: tlbuf holds 5750 atoms
num_get_nodes=18537 num_got_nodes=235 (1.267735 pct)
num_get_links=56472 num_got_links=1116 (1.976201 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=6 num_node_updates=31444
num_link_inserts=256 num_link_updates=20732
Remove 21485 of 64000 (33.570312 pct) calls tlbzz=9219
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 1484 unremapped atoms (20.694464 pct)
sql-stats: 213462841 of 213464601 uuids unused (99.999176 pct)

sql-stats: Atomspace holds 31687 atoms
sql-stats: tlbuf holds 23769 atoms
num_get_nodes=253402 num_got_nodes=1131 (0.446326 pct)
num_get_links=779439 num_got_links=14328 (1.838245 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=70 num_node_updates=517152
num_link_inserts=4190 num_link_updates=340938
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 15624 unremapped atoms (66.088575 pct)
sql-stats: 213763992 of 213783890 uuids unused (99.990692 pct)

sql-stats: AtomSpace not set
sql-stats: Atomspace holds 45225 atoms
sql-stats: tlbuf holds 45225 atoms
num_get_nodes=646388 num_got_nodes=1763 (0.272746 pct)
num_get_links=1988905 num_got_links=33444 (1.681528 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=107 num_node_updates=1339311
num_link_inserts=9898 num_link_updates=883771
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 46231 unremapped atoms (52.940099 pct)
sql-stats: 214585523 of 214645132 uuids unused (99.972229 pct)


sql-stats: Atomspace holds 446035 atoms
sql-stats: tlbuf holds 212056 atoms
num_get_nodes=1572865 num_got_nodes=2519 (0.160154 pct)
num_get_links=4838305 num_got_links=68870 (1.423432 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=215 num_node_updates=3172207
num_link_inserts=22422 num_link_updates=2094051
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 72188 unremapped atoms (28.542847 pct)
sql-stats: 215438536 of 215580711 uuids unused (99.934050 pct)

after 10 hours:
sql-stats: AtomSpace not set
sql-stats: Atomspace holds 731146 atoms
sql-stats: tlbuf holds 725447 atoms
num_get_nodes=20215212 num_got_nodes=6866 (0.033965 pct)
num_get_links=61851573 num_got_links=404021 (0.653211 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=4251 num_node_updates=42211029
num_link_inserts=307398 num_link_updates=27844955
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 411009 unremapped atoms (56.626772 pct)
sql-stats: 240293860 of 241016540 uuids unused (99.700153 pct)

20 gb resident 81 M atoms removed.

Finally:
---------
sql-stats: Atomspace holds 726040 atoms
sql-stats: tlbuf holds 726040 atoms
num_get_nodes=20356005 num_got_nodes=6882 (0.033808 pct)
num_get_links=62281852 num_got_links=405421 (0.650946 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=4264 num_node_updates=42510570
num_link_inserts=309468 num_link_updates=28042704
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 412287 unremapped atoms (56.785714 pct)
sql-stats: 240482670 of 241208711 uuids unused (99.698999 pct)


((gc-time-taken . 7898668634177) (heap-size . 17208950784)
(heap-free-size . 9361924096) (heap-total-allocated . 996784769424)
(heap-allocated-since-gc . 1247263344) (protected-objects . 292)
(gc-times . 1068))

heap is 17.2GB!! free is 9.4GB so 7.8GB in use

((gc-time-taken . 7910648760945) (heap-size . 17208950784)
(heap-free-size . 12845494272) (heap-total-allocated . 996787132704)
(heap-allocated-since-gc . 331136) (protected-objects . 292) (gc-times .
1069))

heap is 17.2GB!! free  12.8GB so actually only 4.4GB is needed.

guile-yue> (sql-close)
guile-yue> (gc)
guile-yue> (gc-stats)
((gc-time-taken . 7912464056925) (heap-size . 17208950784)
(heap-free-size . 16106553344) (heap-total-allocated . 996792364160)
(heap-allocated-since-gc . 164096) (protected-objects . 292) (gc-times .
1070))

free is 16.1GB so somehow the TLB was chewing up 3.3GB holding
412287 unremapped atoms!?  How is this possible? Should I have run gc a
bunch more times? 
-------------------------------------------------------------
New API:
Very fast: in 3 minutes:
sql-stats: Atomspace holds 113815 atoms
sql-stats: tlbuf holds 1195 atoms
num_get_nodes=26378 num_got_nodes=26361 (99.935552 pct)
num_get_links=8813 num_got_links=8251 (93.623057 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=133 num_node_updates=52697
num_link_inserts=1062 num_link_updates=16550
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 0 unremapped atoms (0.000000 pct)
sql-stats: 0 of 1196 uuids unused (0.000000 pct)



wtf...

(cog-report-counts)
((NumberNode . 46505) (ListLink . 163927) (EvaluationLink . 215741)
(AnchorNode . 1) (WordNode . 5199) (ReferenceLink . 99275) (SentenceNode
. 55) (ParseNode . 837) (ParseLink . 835) (WordInstanceNode . 47312)
(WordInstanceLink . 47437) (WordSequenceLink . 47464)
(SentenceSequenceLink . 55) (LinkGrammarRelationshipNode . 1)
(LgConnectorNode . 1) (LgConnMultiNode . 1) (LgConnDirNode . 2)
(LgConnector . 4) (LgAnd . 4) (LgWordCset . 46306) (LgLinkInstanceNode .
52608) (LgLinkInstanceLink . 52715))


Runnning
sql-stats: Atomspace holds 687522 atoms
sql-stats: tlbuf holds 684142 atoms
num_get_nodes=39921257 num_got_nodes=40050951 (100.324875 pct)
num_get_links=13354387 num_got_links=13011199 (97.430148 pct)
num_get_insets=0 num_get_inatoms=0
num_node_inserts=10662 num_node_updates=80083214
num_link_inserts=673480 num_link_updates=26027646
sql-stats: tlbuf holds 0 atoms not in atomspace (0.000000 pct)
sql-stats: tlbuf holds 0 unremapped atoms (0.000000 pct)
sql-stats: 0 of 684143 uuids unused (0.000000 pct)

(gc-stats)
((gc-time-taken . 49802336967563) (heap-size . 14738780160)
(heap-free-size . 9885679616) (heap-total-allocated . 947281529744)
(heap-allocated-since-gc . 1685837392) (protected-objects . 352)
(gc-times . 1242))

So while running: 14.7GB heap, 9.9GB free

guile-yue> (cog-report-counts)
((NumberNode . 737) (ListLink . 337776) (EvaluationLink . 338599)
(AnchorNode . 1) (WordNode . 10670) (ReferenceLink . 1557) (SentenceNode
. 1) (ParseNode . 16) (ParseLink . 16) (WordInstanceNode . 736)
(WordInstanceLink . 736) (WordSequenceLink . 736) (SentenceSequenceLink
. 1) (LinkGrammarRelationshipNode . 1) (LgConnectorNode . 1)
(LgConnMultiNode . 1) (LgConnDirNode . 2) (LgConnector . 4) (LgAnd . 4)
(LgWordCset . 720) (LgLinkInstanceNode . 821) (LgLinkInstanceLink .
821))

while idle:
(cog-report-counts)
((ListLink . 339276) (EvaluationLink . 339276) (AnchorNode . 1)
(WordNode . 10750) (LinkGrammarRelationshipNode . 1) (LgConnectorNode .
1) (LgConnMultiNode . 1) (LgConnDirNode . 2) (LgConnector . 4) (LgAnd .
4))
So the cruuft goes away.

((gc-time-taken . 49831001288560) (heap-size . 14738780160)
(heap-free-size . 5885931520) (heap-total-allocated . 956146319472)
(heap-allocated-since-gc . 4515746160) (protected-objects . 296)
(gc-times . 1243))

Heap:free: 5.9GB wow -- lots smaller than while runing.
Because 4.5GB alloced since last gc
(heap-free-size . 9419513856)
(heap-free-size . 13306900480)
(heap-free-size . 13710024704) 
(heap-free-size . 13740257280)  wow
of
(heap-size . 14738780160) 14.7 so only 1 GB needed.




ten-word-java: 289105 bytes 2m18 backlog
20-word java: 550294 bytes 3m12.772s
40-word hava: 1101459 bytes: 3m15 delay


ignoreType is not being used

 Wow .. the remove is completely un-needed!  DONE

The "Loaded 370000 atoms" not needed at all, if not bulk-loading. DONE

this dead-locks the shell:
(observe-test "商 餘 質 數 分 解 質 數 定 理 相 對 質 數")
ERROR: In procedure apply-smob/1:
ERROR: Throw to key `decoding-error' with args `("scm_from_utf8_stringn"
"input locale conversion error" 29 #vu8(40 111 98 115 101 114 118 101 45
116 101 115 116 32 34 229 149 134 32 233 164 152 32 232 179 170 32 230
149 184 32 229 136 134 32 232 167 163 32 232 179 170 32 230 149 184 32
229 174 255 237 255 253 6 10))'.

ERROR: In procedure fetch-atom: Earlier version of atom has mis-matched
UUID! (/home/ubuntu/src/atomspace/opencog/atomspaceutils/TLB.cc:85)


---------------------------------------------------------------
-- fix TLB tables in sql -  underway
    (deadlock) DONE

-- fix sennas bug.  DONE
-- publish new LG DONE
---------------------------------------------------------------

The fetch not needed if in the atomspace already. Well,
then don't fetch it!

There is no TV invalidation mechanism...
---------------------------------------------------------------
-- fetch not requied, unless updating the TV ... !!
   (or getting the tv...
-- fix pgsql variant .. maybe
-- update all lxc's.

=======================================================================
20 Jan 2017 Friday
OK, all bugs above fixed, reinstalled the latest LG in yue,
erase all tables, start from scratch. At 4PM exactly, wall-clock time
to the second.

at start
$ find beta-pages |wc          49193   52687 1489227
$ find submitted-articles |wc     24      24     629

-------

After 40 minutes:
select count(*) from atoms;   111632
Java/do-count: 1064 sentences  
find submitted-articles |wc      205

so, rate: 4.5 articles/minute, 5.9 sentences/article.
rate: 26.6 sents/minute
projected finish: 182 hours === 7.5 days

(do-count "report-stuff") gives alternate sentence count...


------

After 4.000 hours:
select count(*) from atoms;    454240
Java: cnt=6533  but 6610 from do-count !! wtf.
$ find submitted-articles |wc 919
38.9M node insert/updates   7164 total nodes!?
12.99 link insert/updates   447516 total links!?
== 51946920 total stores, so that cross-checks OK
total number of atoms also checks out (skew for measurement delay) OK

so, rate: 3.73 articles/minute, 7.4 sents/article
rate: 27.5 sents/minute
projected finish: 220 hours = 9.1 days

So the article-rate is bouncing around, but sentences/minute holds
steady.  Numbers are checking out.

-------

After 8.00 hours:
select count(*) from atoms;  666606
Java: cnt=10787 but  do-count says cnt=11464
$ find submitted-articles |wc 1634
66.1M node updates
22.0M link updates

So...
rate: 1610 / 8 hours = 201 articles/hour, 3.35 articles/minute
rate: 11464 / 480 min = 23.9 sents/min

22 minutes downtime for system upgrade....


4 concurrent writers:
after 15 mins: 
write items=417737 drains=2532 fill_fraction=164.983017 concurrency=51.921801

after 20 mins cpu:
write items=616070 drains=3826 fill_fraction=161.021955 concurrency=53.232358


12 concurrent writers:
after 15 mins
write items=372257 drains=1805 fill_fraction=206.236565 concurrency=53.760111

after 20 mins:
write items=539921 drains=2802 fill_fraction=192.691292 concurrency=54.867595

... doesn't improve concurrency, and seems slower for total CPU, but
that may be fucked up java. ... XXX see below: because there were only
6 connections to postgres, so really of the 12 writers, 7 were blocked.
(assumiong one reader thread, or more...)


New code, where no atom get: (and 12 writer threads)

write items=21516264 drains=167609 fill_fraction=128.371770 concurrency=4.759196
avg drain time=0.345310 seconds; longest drain time=80.337000

New code, 12 writers, and C impl of count-increment:
write items=7817004 drains=61061 fill_fraction=128.019587 concurrency=3.714679
avg drain time=0.517914 seconds; longest drain time=29.733000


New code, 4 writers, and C impl of count-increment:
drains=7186 fill_fraction=136.883245 concurrency=3.445728
drains=25794 fill_fraction=124.202528 concurrency=3.613825
avg drain time=0.440724 seconds; longest drain time=5.136000

4 writers is not obvious worse and seems better than 12.

Ohh .. well, turns out there were only 6 odbc connections
available to work with.

--------------------------------------------------
21 January -- saturday -- start from scratch, again.

start at exactly 15:00

after 15 mins:
select count(*) from atoms; 66221
find submitted* |wc  127

sql-stats: total loads = 296 total stores = 4379768 ratio=14796.513514

num_get_nodes=4246 num_got_nodes=296 (6.971267 pct)
num_get_links=61974 num_got_links=0 (0.000000 pct)
num_get_insets=0 num_get_inatoms=0 ratio=-nan
num_node_inserts=2123 num_node_updates=3282677 ratio=1546.244465
num_link_inserts=61974 num_link_updates=1033002 ratio=16.668313
total stores for node=3284800 link=1094976 ratio=2.999883

write items=2189854 flushes=0 flush_ratio=inf
drains=17804 fill_fraction=122.997866 concurrency=3.866659
avg drain time=0.418640 seconds; longest drain time=4.090000

(monitor-rate "foo")

------------
18:15 -- 3hrs 15 mins later:
find submitted* |wc gives 1025 so 
exactly 1000 articles in 195 minutes = 5.12 articles per minute

select count(*) from atoms; 482295
total loads = 803 total stores = 55843525 
num_node_inserts=7427 num_node_updates=41875213 ratio=5638.240609
num_link_inserts=472298 num_link_updates=13488591 ratio=28.559492
total stores for node=41882640 link=13960889 ratio=2.999998

write items=27921766 flushes=0 flush_ratio=inf
drains=234012 fill_fraction=119.317667 concurrency=2.665735
avg drain time=0.348755 seconds; longest drain time=6.107000

why is write-items=27.9M but total stores=55.8M ?

write-items is exactly half of total stores ...
select sum(stv_count) from atoms; gives 28995086 shortly later.

they're close ... so write-items actually matches word-counting...
so we are double-storing somehow...

-------------------------------------------------
on shutdown, at 22:30 --
select sum(stv_count) from atoms; 62921108
select count(*) from atoms; 861867

find submitted* |wc 2314  

total stores = 125995216
write items=62997608

write items=62997608 flushes=0 flush_ratio=inf
drains=532502 fill_fraction=118.304923 concurrency=2.559669
avg drain time=0.344836 seconds; longest drain time=6.107000

Rearrange; total stores still running at 2x write-items.

But ... 2 links, 3 nodes:
  Eval link --
     Pred node
     List link
        left node
        right node

so the list link is never explicitly stored.  which leaves 1 link, 3
nodes being explicit i.e. 4 explicit stores (for 5 atoms)
is write-items counting only the links? that would be only two, in tat
case...  but the write items are counted in the queue.



--------------------------------------------

Bugs:
if there is a store in the queue, and there is is a get for something
in the queue, then the get will get stale data, and then try to write
back more stale data, ad infinitum... causing the counts to be bad.

well, its up to user to use the barrier, which should now work.

 So .. need mechanism to fetch locally, until fully retired!
Better yet, in scheme, just don't .. don't what? 
don't fetch, unless stv is the default stv ...!

-----------------------------------------------
23 Jan 2017:
------------
Holy cow -- postgres is sooo much faster!!
check this out:

after just a few minutes:

write items=94794 flushes=0 flush_ratio=inf
drains=70 fill_fraction=1354.200000 concurrency=4.385714
avg drain time=0.065023 seconds; longest drain time=0.623000


fill fraction used to be only about 150, before, and average drain time
was something like 0.3 seconds... this is a whole new ballgame!

after 1/2 hour wall clock
write items=1462482 flushes=0 flush_ratio=inf
drains=1830 fill_fraction=799.170492 concurrency=5.049180
avg drain time=0.080646 seconds; longest drain time=1.829000

after 100 minutes
write items=4580980 flushes=0 flush_ratio=inf
drains=5394 fill_fraction=849.273267 concurrency=4.693919
avg drain time=0.118629 seconds; longest drain time=70.343000

after 7 hours
write items=18375732 flushes=0 flush_ratio=inf
drains=21386 fill_fraction=859.241186 concurrency=4.406621
avg drain time=0.084344 seconds; longest drain time=70.343000

after 13 hours:
write items=32066762 flushes=0 flush_ratio=inf
drains=37044 fill_fraction=865.639834 concurrency=4.370316
avg drain time=0.077263 seconds; longest drain time=70.343000

after 24 hours:
write items=56233665 flushes=0 flush_ratio=inf
drains=67199 fill_fraction=836.822944 concurrency=4.378875
avg drain time=0.072986 seconds; longest drain time=70.343000

So this looks to be stable.
after 3 days:
write items=199535356 flushes=0 flush_ratio=inf
drains=310946 fill_fraction=641.704206 concurrency=5.116091
avg drain time=0.087041 seconds; longest drain time=70.343000

so its ogt a little worse... but atomspace is much much bigger, now.


---------------
and also: java is fixed: the magic fix was:
-- shut everything down every 500 sentences,
-- run gc five times in a row,
-- restart everything. 
This unclogs the kitchen sink. -- java now stays up for 4+ hours,
without tanking.

progress:
as of 23 jan 01:50 AM have find submitted* |wc being 8198
              2:15 AM 8299  and (monitor-rate "foo") cnt=2080 rate=0.740
                   i.e. 0.74 sents/sec = 44 sents/minute!
                     that's nearly double the previous rate.
              9:15 AM 10711 -> 10711-8299=2412/(7*60+25) = 5.4 articles/min
                            -> 325 articles/hour = 7805 articles/day
                       cnt=18200 rate=0.65566 -> 39 sentences/minute
              10:47 AM cnt=21430 rate=0.640945
              12:43 PM cnt=27054 rate=0.668858
              15:04 PM cnt=33874 rate=0.692012
      24 jan  01:34 AM cnt=57497 rate=0.663148
                       18160 articles->(18160-8198)/24 = 415 articles/hour
                       10K articles/day
      25 Jan  12:04 PM cnt=134017 rate=0.63543
                       27967 articles->(27967-8198)/59 = 335 articles/hour
      26 Jan  15:26 PM cnt=196794 rate=0.63602
                       35736 articles


-----------------
CentOS 5

psql opencog_test -U opencog_tester -W -h localhost

PGPORT=5433
PGDATA=/home/linas/postgres/var/lib/pgsql/data
PGLOG=/tmp/pgstartup.log

postgres -c "/usr/bin/postmaster -p '$PGPORT' -D '$PGDATA' &" >> "$PGLOG" 2>&1 
postgres -c "/usr/bin/postmaster -p 5432 -D /home/linas/postgres/var/lib/pgsq/data &" >> /home/linas/postgres/tmp/pgstartup.log 2>&1 

alt: chroot /home/linas/postgres; /etc/init.d/postgresql start
nooo dudn't work.

just this:
/home/linas/postgres/etc/init.d/postgresql start

/usr/bin/postmaster -p 5432 -D /home/linas/postgres/var/lib/pgsql/data &
>> /home/linas/postgres/tmp/pgstartup.log 2>&1 

psql opencog_test -U opencog_tester -W -h localhost
Nooooo
look at .odbc.ini

psql test-persist -p 6543

CREATE TABLE Spaces (
    space  BIGINT PRIMARY KEY,
    parent BIGINT
);  
INSERT INTO Spaces VALUES (0,0); -- no space defined; raw atoms.
INSERT INTO Spaces VALUES (1,1); -- default root

ALTER TABLE atoms ADD COLUMN space INT REFERENCES spaces(space);

select count(*) from atoms;
select sum(stv_count) from atoms;


all of these are only the ANY type:

fr_pairs -- learn-fr -- 11161199 (11M) atoms, 6842302577 (6.8G) count
                         ANY-count = 1200368900 = 1.2GB relations

lt_pairs -- learn-lt --  9798103 (10M) atoms, 2873920459 (2.8G) count
                         ANY-count = 647356630 = 0.65G relations

pl_pairs -- learn-pl -- 16192701 (16M) atoms, 4331274070 (4.3G) count
                         ANY-count = 1061898400 = 1G relations

simple_pairs -- learn-simple -- empty
pair_data -- 532 atoms, junk

frwiki-20131220-pages-articles
   find alpha-pages |wc -- 1452754 - 1.4M
   find beta-pages |wc -- 1436278 
   find submitted-articles |wc -- 16505

plwiki-20131218-pages-articles
   find alpha-pages | wc -- 1007645 -- 1.0M
   find submitted-articles |wc -- 107190

ltwiki-20131216-pages-articles
   find alpha-pages | wc -- 161488 -- 161K
   submitted-articles |wc -- 18108

fr_ady : mophology pairs.
.odbc.ini -> fr-ady

relex is not spewing ady correctly -- FIXED

fr-ady on 17003, ady relex on 4446

Warning: Combinatorial explosion! nulls=1 cnt=2147483647
FIXED -- hacked on LG; works-ish, but slow for long sentences.

psql -p 6543 fr_ady
select type, name,stv_count from atoms where height=0;

Argh.
after a day: guile hung; but also, no articles moved from
split to submitted!

crash: string_set_add + 0x47
000000000003ad90 t string_set_add

  e0:	84 c9                	test   %cl,%cl
  e2:	0f 84 89 01 00 00    	je     271 <string_set_add+0x1b1>
  e8:	48 8b 36             	mov    (%rsi),%rsi
  eb:	49 89 f8             	mov    %rdi,%r8
  ee:	0f b6 d1             	movzbl %cl,%edx
  f1:	45 31 ed             	xor    %r13d,%r13d
  f4:	0f 1f 40 00          	nopl   0x0(%rax)
  f8:	41 c1 e5 08          	shl    $0x8,%r13d
  fc:	49 83 c0 01          	add    $0x1,%r8
 100:	41 8d 44 15 00       	lea    0x0(%r13,%rdx,1),%eax
 105:	31 d2                	xor    %edx,%edx
 107:	48 f7 f6             	div    %rsi

but RSI is zero

liblink-grammar.so.5+0x3b6b3]  int+0x3
000000000003b6b0 t is_capitalizable.isra.9


PrintWriter out -- done
outs  OutputStream  done
in_sock  Socket  -- done
send_sock Socket  ... is null

23:30: 2159 articles
23:43: 2535 articles : 276/13 minutes = 21 articles/min

23:48  2540 articles
23:59  2872 articles : 332 aritcles/ 11 mins = 30 articles/min! waa

00:45  3651 articles
select sum(stv_count) from atoms; 1375507899  == 1.38 G counts
select count(*) from atoms; 7146891 == 7.1M atoms

# C  [liblink-grammar.so.5+0x120d5]  print_flat_constituents+0xbd5
# C  [liblink-grammar.so.5+0x120d5]  print_flat_constituents+0xbd5

from 
C  [liblink-grammar.so.5+0x12a25]  linkage_print_constituent_tree+0x85

4180 + bd5 = 4d55
objdump -d -F -g -S

in build tree:
0000000000011500 t print_flat_constituents
00000000000120e0 t print_tree

in build tree so:


4ccd:
   1207f:   31 c9                   xor    %ecx,%ecx
   12081:   31 c0                   xor    %eax,%eax
   12083:   e8 78 2a 01 00          callq  24b00 <feature_enabled>
   12088:   48 85 c0                test   %rax,%rax
   1208b:   0f 85 1f ff ff ff       jne    11fb0
<print_flat_constituents+0xab0>
   12091:   eb d6                   jmp    12069
<print_flat_constituents+0xb69>
   12093:   48 89 c3                mov    %rax,%rbx
   12096:   48 8b 00                mov    (%rax),%rax
   12099:   48 8b b8 98 00 00 00    mov    0x98(%rax),%rdi
   120a0:   e8 9b 89 01 00          callq  2aa40 <post_process_new>
   120a5:   48 89 c7                mov    %rax,%rdi
   120a8:   48 89 bb 88 00 00 00    mov    %rdi,0x88(%rbx)
   120af:   e9 ff f7 ff ff          jmpq   118b3
<print_flat_constituents+0x3b3>
   120b4:   e8 47 3e ff ff          callq  5f00 <__stack_chk_fail@plt>
   120b9:   48 8d 3d b0 00 05 00    lea    0x500b0(%rip),%rdi        # 62170 <__func__.7560+0x8f0>
   120c0:   31 c0                   xor    %eax,%eax
   120c2:   e8 e9 3b ff ff          callq  5cb0 <prt_error@plt>
   120c7:   48 8d 3d ac bf 05 00    lea    0x5bfac(%rip),%rdi        # 6e07a <_ZTSN7Minisat6SolverE+0xca>
4d22:
   120ce:   31 c0                   xor    %eax,%eax
   120d0:   e8 db 3b ff ff          callq  5cb0 <prt_error@plt>
>>>>>>>>>>>>>>>>>>>> crash here.
   120d5:   0f 0b                   ud2
   120d7:   48 8d 3d 0a 00 05 00    lea    0x5000a(%rip),%rdi        # 620e8 <__func__.7560+0x868>
   120de:   eb e0                   jmp    120c0 <print_flat_constituents+0xbc0>

OK
00000000000120e0 <print_tree>:
   120e0:   48 85 d2                test   %rdx,%rdx
   120e3:   0f 84 ab 08 00 00       je     12994 <print_tree+0x8b4>
   120e9:   41 57                   push   %r15
   120eb:   41 56                   push   %r14
   120ed:   49 89 ff                mov    %rdi,%r15
   120f0:   41 55                   push   %r13

So: 

blank banshee
I just wasn't made for these times -- beach boys -- pet sounds

linkage_print_constituent_tree
getConstituentString
LinkGrammar.java -- wraps the C api w/static funcs
    public static native String getConstituentString();
LGService.java -- where the struture is restored
if (config.isStoreConstituentString())


finish
Java_org_linkgrammar_LinkGrammar_close(JNIEnv *env, jclass cls)
    public static native void close();

LGService.do_finalize()

allowSkippedWords
setAllowSkippedWords

linkgrammar_get_dict_version+0x0  <-- crash here twice ...
parser.parse(sentence);

parseSentence   159

parser.parse(sentence);

start again yue 30 Jan 22:19 
at 22:49 -- 488 articles/30 minutes = 16 articles/minute! -- 3x faster than before.
at 23:48 -- 796 articles in 90 minutes = 9 artciles/min
at 00:19 -- 926 articles in 120 mins = 7.7 articles/min
            4500 sents = 4.86 sents/article
            22908000 stored, stv total = 18315330
            stv/5 = 3.66M pairs or 814 pairs/sent(!)
at 11:55 -- 4275 articles in 816 mins = 5.24 articles/min - back to old rates.
            restart java, no noticable diference in rate: its same cpu/loadavg
restart, and load all. Before stopping:
            tlbuf holds 1381888 atoms Atomspace holds 1381901 atoms Hmm.

restart: explicit load: 1381888 atoms in 31 cpu-secs: 44.6K atoms/sec load speed.
at 12:13 -- restarted. Baseline: 4304 articles
at 18:13 -- 6094-4304 = 1790/6 hrs = 4.97 articles/min
at 00:26 -- 7547-6094 = 1453/373 mins = 3.90 articles/min
at 12:22 -- 12376-7547 = 4829/716 mins = 6.74 articles/min (!)
24-hour avg: 12376 - 4304 = 8072/1449min = 5.57 articles/min

1 Feb 2017:
change postgres shared_buffers = 24576MB  from 1GB previously.
also -- change java to 2GB from 1GB
restart at 12:31 no explicit load.
at 14:14 -- 13926 - 12376 = 1550/103min = 15.0 articles/min(!)

at 15:40 - 12:31 = 189 mins, have 
         guile=637:07 mins, or 637/189 = 3.37 load
         java = 50:25 = 50/189 = 0.267 load
         postgres = 10974 secs = 182.9 mins = 182.9/189 = 0.968 load

at 21:27  -- 17014 - 13926 = 3088 / 433 mins = 7.13 articles/min

at 21:30 - 12:31 = 539 mins
        guile = 1850:15 / 539 = 3.42 load
        java  =  148:04 / 539 = 0.274 load
        postgres = 519 / 539 = 0.963 load

2 Feb 2017 -- guile crashed! no prints no dump. 
restart at 12:05 -- 21174 articles
        at 12:43 -- 21411 articles = 411-174/38 = 237/38 = 6.2 artciles/min
        at 19:28 -- 23422 articles = 23422-21174/443 = 2248/443 = 5.07 arts/min
3 Feb   at 07:46 -- 26828 articles = 26828-23422/738 = 3406/738 = 4.62 arts/min
           11:45 -- 27691 articles = 27691-26828/239 = 863/239 = 3.61 arts/min

Hmm. the rate keeps dropping...

final stats for above:
sql-stats: total loads = 1228941 total stores = 286453870 ratio=233.090010
write items=57290774 flushes=0 flush_ratio=inf
drains=98324 fill_fraction=582.673345 concurrency=6.286054
avg drain time=0.109933 seconds; longest drain time=9.216000

scheme@(guile-user)> (gc-stats)
$9 = ((gc-time-taken . 19242586423) (heap-size . 5229101056) (heap-free-size .
5109686272) (heap-total-allocated . 3874090716576) (heap-allocated-since-gc . 509440)
(protected-objects . 301) (gc-times . 53424))

select sum(stv_count) from atoms; -- 801969742 -- 802M
select count(*) from atoms; -- 4786479 -- 4.8M


3 Feb 2017 -- restart. All-new atomspace, all-new link-grammar
      at 12:18PM -- 27691 articles 
      at 12:30 -- crash of guile, restart.
      at 14:11 -- 28246 articles, 28246-27691/100 = 555 / 100 = 5.5 arts/min
      at 15:47 -- 28772 articles, 28772-28246/96 = 526 / 96 = 5.48 articles/min
      at 20:03 -- 30166 articles, 30166-28772/256 = 1394/256 = 5.45 arts/min
4 Feb at 11:20 -- 35014 articles, 35014-30166/917 = 4848/917 = 5.29 artciles/min
5 Feb at 00:02 -- 38511 articles; there was accidental pause of system for hours.
      at 11:25 -- 43905 articles; 43905-38511/683 = 5394/683 = 7.90 arts/min whoa!
6 Feb completed -- 49194 articles.

sql-stats: total loads = 2013739 total stores = 741785040 ratio=368.362057
write items=148357008 flushes=0 flush_ratio=inf
drains=256330 fill_fraction=578.773487 concurrency=5.138489
avg drain time=0.100850 seconds; longest drain time=10.537000

select count(*) from atoms;           6927244 -- 6.9M  -- 6 Feb final
select sum(stv_count) from atoms;  1396889746 -- 1.40G -- 6 Feb final


cpu-ratio guile/java: 4846/425 = 11.4 at 11:20 4 Feb
                      6732/602 = 11.2 at 00:02 5 Feb
                      9001/786 = 11.5 at 11:30 5 Feb
                     12532/1127 = 11.1 final 6 Feb at completion

114022593 total stores in  1820 cpu-mins = 62.6K atoms/min = 1.04K sto/sec
292674070 total stores in  4846 cpu-mins = 60.4K atoms/min = 1.01K sto/sec
534084730 total stores in  8978 cpu-mins = 59.5K atoms/min = 991 stores/sec
741785040 total stores in 12532 cpu-mins = 59.2K atoms/min = 987 stores/sec

 vs cx1 (fr-ady):
 76688189 stores in  3325 cpu-mins = 23.1K stores/min = 384 stores/sec
193457228 stores in  6838 cpu-mins = 28.3K stores/min = 472 stores/sec
378934530 stores in 12396 cpu-mins = 30.6K stores/min = 509 stores/sec

cx1 has old, inefficient kernel and/or old-ineffcient postgres (and
crappy odbc)


postgres:
ps ax |grep postgres > x
cat  x |cut -f 4 > y


EPOCH='jan 1 1970'
sum=")"

for i in 00:03:34 00:00:35 00:12:34
do
  sum="$(date -u -d "$EPOCH $i" +%s) $sum"
done
echo "(+" $sum| guile

=====================================================================
French pairs

french pairs: start again: 22:36PM 30 Jan - find submitted* |wc 17053 
                           12:25PM  2 Feb - find submitted* |wc 24563
                           11:43AM  4 Feb - find submitted* |wc 25361
                           11:34AM  5 Feb - find submitted* |wc 25830
                           19:19PM 10 Feb - find submitted* |wc 27763
                           20:16PM 14 Feb - find submitted* |wc 29720

disk: 206447916 used 41097304 free
disk  206574808 used 40970412 free  24 hours later... about 100MB more
disk  206888724 used 40656496 free  12:25 2 Feb
disk  208585480 used 38959740 free  11:42 4 Feb ... 2.1GB more
disk  208897572 used 38647648 free  00:00AM 5 feb
disk  211829000 used 35716220 free  19:20 10 Feb
disk  213607532 used 33937688 free  20:16 14 Feb

select count(*) from atoms;         2090064 --   2.1M -- 12:25PM  2 Feb
select sum(stv_count) from atoms; 115251031 -- 115M   -- 12:25PM  2 Feb

select count(*) from atoms;          5676118 --    5.7M -- 11:19AM  4 Feb
select sum(stv_count) from atoms;  351323640 --  351M   -- 11:19AM  4 Feb

select count(*) from atoms;          7714679 --    7.7M -- 11:38AM  5 Feb
select sum(stv_count) from atoms;  502509756 --  503M   -- 11:38AM  5 Feb

select count(*) from atoms;         16945084 --   16.9M -- 19:21PM 10 Feb
select sum(stv_count) from atoms; 1289249056 -- 1.29G   -- 19:21PM 10 Feb

select count(*) from atoms;         23072988 --   23.1M -- 20:20PM 14 Feb
select sum(stv_count) from atoms; 1856669388 -- 1.86G   -- 20:20PM 14 Feb


guile/java ratio: 6781/683  = 9.93 -- 11:19AM  4 Feb
                  9401/1001 = 9.40 -- 00:00AM  5 Feb
                 12433/1304 = 9.53 -- 11:40AM  5 Feb
                 47250/4576 = 10.3 -- 19:23PM 10 Feb
                 22980/2340 = 9.82 -- 20:20PM 14 Feb

guile hangs:
cx1 - 30 jan hang after 4.4M stores 
      31 jan hang after 42M stores
       1 Feb hang after 33M stores -- 2000:26 cpu
       1 Feb hang after 6.9M stores
       2 Feb hang
       2 Feb hang after 20M stores -- 865:47 cpu


155 threads

155: pthread_cond_wait - multi-driver/SQLAtomStorage.cc:325

Ahhh ... too many open sockets, and one is deadlocked.

wait ... deadlocked in conn_pool.pop()
in SQLAtomStorage::get_conn() SQLAtomStorage.cc:325

so who is using all these conns?

154: ~GenericShell 152 150 148 .. 130 .. 127

153: same as 155 151 149 147 ... 131 .. 128

alternates like this till 131 or so

129: SchemeEval::do_poll_result SchemeEval.cc:655  86

90 76: nanosleep --SQLAtomStorage::storeAtom SQLAtomStorage.cc:754
    waiting to drain ... so its not draining ... why?

25: GC25: GC

24: get_conn, do_store_single --- this is the write-back handler.
    there are 8 of these .. through 17 

so .. the 8 busy writers are blocking readers, cause there are only 8
conns total ... 

works better if we double the pool...

no one seems to be waiting on postgres ... suggests that the 
we've lost track of the number items in the queue ...

15: console list
14: logger
13-2: gc
12

So, its idle ... and ... we've leaked:
currently in_drain=0 num_busy=0 queue_size=0
current conn_pool free=4 of 20


ahhh its due to throws, which kill the put_conns ...

[2017-02-03 05:44:02:785] [WARN] (34) The # of binded parameters < the #
of parameter markers;
Unrecognized key passed to SQLGetInfo30.

[2017-02-03 05:44:02:785] [WARN]    Query was: SELECT * FROM Atoms WHERE
type = 110 AND name = $ocp$?$ocp$ ;

[2017-02-03 05:44:02:785] [ERROR] Can't perform query rc=-1
(/home/linas/src/atomspace-git/opencog/persist/sql/multi-driver/odbcxx.cc:259)
   Stack Trace:

Query was: SELECT * FROM Atoms WHERE type = 110 AND name =
$ocp$?,!ANY-PUNCT$ocp$ ;

... need to try-catch these blocks.

SELECT * FROM Atoms WHERE type = 110 AND name = $ocp$?$ocp$ ;
Seems to be an ODBC issue ...

(34) The # of binded parameters < the # of parameter markers;
Unrecognized key passed to SQLGetInfo30.

SQLBindParameter


glurg. ODBC needs this: replace ? by &#63; what a clusterfuck

Also: 

[2017-02-08 08:16:43:154] [WARN] ODBC Driver: (1) ODBC escape convert
error

[2017-02-08 08:16:43:155] [WARN] ODCB Driver: Query was: SELECT * FROM
Atoms WHERE type = 110 AND name = $ocp${x$ocp$ ;

[2017-02-08 08:16:43:155] [ERROR] Can't perform query rc=-1
(/home/linas/src/atomspace-git/opencog/persist/sql/multi-driver/odbcxx.cc:340)




------------------
very late:
link-grammar: Info: Dictionary 'ady/4.0.dict': No locale definition -
"en_US.UTF-8" will be used.
link-grammar: Info: Dictionary 'ady/4.0.dict': No locale definition -
"en_US.UTF-8" will be used.
link-grammar: Error: Could not open dictionary "ady/4.0.dict"


restart not happen until connection... OK.
link-grammar not loaded until the next round!

re.setMaxParses

_is_in
dict=0x7f053c1bb0b0
dict=0x7f2e2c1f35a0
local-ptd=0x7f2e2c1f3550

checking for locale_t in locale.h... no
checking for locale_t in xlocale.h... no

__USE_GNU
       semant = new AlgorithmApplier(
         "relex.semalgpath", "relex-semantic.algs");

wordnet.configfile file_properties.xml

src/java/relex/morphy/MapMorphy.java:
src/java/relex/morphy/MorphyFactory.java:

               getJWNLConfigFileStream(
                     WORDNET_PROPERTY,
                     JWNL_FILE_PROPERTIES_XML,
                     JWNL_DIR_PROPERTIES_XML
               )

Info: hndlr=3 recv input: "- |3-1|25-23|20-25|25-17|25-11||95-76|couleur=gris}} - |3-0|28-26|25-19|25-23|||78-68}} - |3-1|25-21|25-21|13-25|25-12||88-79|couleur=gris}} - |3-1|21-25|33-31|40537|25-15||104-83}} - |3-2|25-23|22-25|25-22|17-25|17-15|106-110|couleur=gris}} - |3-0|25-19|25-13|25-23|||75-55}}"

Info: hndlr=8 recv input: "- |3-0|25-16|26-24|25-17|||76-57|couleur=gris}} - |3-1|25-22|23-25|25-20|25-20||98-87}} - |3-2|25-22|20-25|25-27|33-31|15-12|118-117|couleur=gris}} - |3-0|25-14|25-22|25-19|||75-55}} - |3-0|25-14|25-20|25-21|||75-55|couleur=gris}} - |3-0|26-24|25-18|33-31|||84-73}}"

then crash

"ISBN 0-380-72001-9.  http://books.google.be/books?id=FMsNAG-gresC&pg=PA144&lpg=PA144&dq=vlakfontein+Dixon+kemp&source=web&ots=8cB7anqlpV&sig=REOVNA8sQO8iTZhI-0_IHVdhySQ&hl=en&sa=X&oi=book_result&resnum=3&ct=result."


crash again:
C  [libc.so.6+0x7a97b]  unsigned long+0xa5b
C  [liblink-grammar.so.5+0x3dad4]  short+0x164
3dad4 - 164 = 3d970

000000000003d970 t separate_word.isra.12

if (not dict->affix_table ) jump pst anysplit
   3dab8:   74 1a                   je     3dad4 <separate_word.isra.12+0x164>
   3daba:   48 83 78 58 00          cmpq   $0x0,0x58(%rax)
if (not dict->affix_table->anysplit) jump past anysplit
   3dabf:   74 13                   je     3dad4 <separate_word.isra.12+0x164>
   3dac1:   48 8b b5 30 ff ff ff    mov    -0xd0(%rbp),%rsi  # arg2: unsplit_word
   3dac8:   48 8b bd 20 ff ff ff    mov    -0xe0(%rbp),%rdi  # arg1: sent
   3dacf:   e8 4c a9 fc ff          callq  8420 <anysplit>
   3dad4:   48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx  # arg3: word
crash here
RBP=0x00002b9ecaf2e450, RDX=0x0000000000000000

call convention arg 1 2 3 in RDI RSI RDX

looks like RBP is pointing into the stack... and 0x00002b9ecaf2e3c0 is
null ...

0x00002b9ecaf2e3a8:   00002b9eeef04f10 000000004bb2c580
0x00002b9ecaf2e3b8:   00002b9e00000000 0000000000000000
0x00002b9ecaf2e3c8:   0000000000000000 00002b9eec065490
0x00002b9ecaf2e3d8:   fffffffe00000026 00002b9ecaf2e310
0x00002b9ecaf2e3e8:   0000000000000001 00002b9e00737470

OK, this is fine, the crash is somewhere inside of anysplit.

unsplit word is.... at 0x00002b9ecaf2e450 - d0 = ...380 

0x00002b9ecaf2e380: 000000004bb2c960 -- same as contents to rbx



   3dadb:   48 8b b5 30 ff ff ff    mov    -0xd0(%rbp),%rsi  # arg2: unsplit_word
   3dae2:   48 8b bd 20 ff ff ff    mov    -0xe0(%rbp),%rdi # arg1: sent
   3dae9:   e8 a2 f8 ff ff          callq  3d390 <morpheme_split>
   3daee:   80 bd 1f ff ff ff 00    cmpb   $0x0,-0xe1(%rbp)
   3daf5:   89 c3                   mov    %eax,%ebx
   3daf7:   75 2e                   jne    3db27 <separate_word.isra.12+0x1b7>
   3daf9:   84 c0                   test   %al,%al

==================================
again
https://sourceware.org/bugzilla/show_bug.cgi?id=21104

Info: hndlr=1 sentence: "Chaussande (de) [http://gallica.bnf.fr/ark:/12148/bpt6k1120033/f177.image.r=], baron par bref pontifical de 1707, Comtat Venaissin, ANF-1969."
*** glibc detected *** java: free(): invalid pointer: 0x0000000059551940
***
======= Backtrace: =========
/lib64/libc.so.6[0x3e296714af]
/lib64/libc.so.6(cfree+0x4b)[0x3e296757ab]
/usr/local/lib/liblink-grammar.so.5[0x2b3a2392a7ce]
/usr/local/lib/liblink-grammar.so.5[0x2b3a2392b396]
/usr/local/lib/liblink-grammar.so.5(sentence_parse+0x99)[0x2b3a2392bb69]
/usr/local/lib/liblink-grammar-java.so.5.3.15(Java_org_linkgrammar_LinkGrammar_parse+0xf5)[0x2b3a236f8995]
[0x2b3a1690eeee]


#5  0x00002b3a2392a7ce in wordgraph_path_free (free_final_path=true, wp=0x59551860)
    at ../../link-grammar/api.c:937
#6  sane_linkage_morphism (sent=sent@entry=0x586bb130, lkg=lkg@entry=0x5877b850, 
    opts=opts@entry=0x586baef0) at ../../link-grammar/api.c:1021


(gdb) print twp
$1 = (Wordgraph_pathpos *) 0x59551890
(gdb) print *twp
$3 = {word = 0x587d7f40, same_word = 56, next_ok = 74, used = 149, path = 0x59551940}

(gdb) x/16g 0x59551940
0x59551940:	0x00000000587d6ef0	0x0000000000000000
0x59551950:	0x0000000000001270	0x0000000000000021
0x59551960:	0x000000005894f650	0x0000003e29954a68
0x59551970:	0x0000000000000020	0x0000000000000040
0x59551980:	0x00000000595516f0	0x000000005a5c82a0

Hmm everything looks OK, so what's the problem???

struct Wordgraph_pathpos_s
{
   Gword *word;      /* Position in the Wordgraph */
   /* Only for wordgraph_flatten(). */
   bool same_word;   /* Still the same word - issue an empty word */
   bool next_ok;     /* OK to proceed to the next Wordgraph word */
   bool used;        /* Debug - the word has been issued */
   /* Only for sane_morphism(). */
   const Gword **path; /* Linkage candidate wordgraph path */
};

wordgraph_pathpos_resize could take bigger jumps.


wordgraph_pathpos_len

len == len not counting the null.

e.g. n=1 insert = 0
memomve from 0 to 1 for 1 item

=========================================================
Arghh...
scheme@(guile-user)> GC Warning: Repeated allocation of very large block (appr. size
18894848):
        May lead to memory leak and poor performance.
*** Error in `guile': double free or corruption (out): 0x00000000623e6010 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f3a6db117e5]
/lib/x86_64-linux-gnu/libc.so.6(+0x7fe0a)[0x7f3a6db19e0a]
/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f3a6db1d98c]
/usr/local/lib/libguile-2.2.so.0(scm_string_to_utf8+0xd7)[0x7f3a6e0ca067]
/usr/local/lib/libguile-2.2.so.0(scm_mkstrport+0x6b)[0x7f3a6e13d0ab]
/usr/local/lib/libguile-2.2.so.0(+0xbc5cd)[0x7f3a6e1465cd]
/usr/local/lib/libguile-2.2.so.0(scm_call_n+0x186)[0x7f3a6e154046]
/usr/local/lib/libguile-2.2.so.0(scm_call_3+0x2f)[0x7f3a6e0d2eaf]
/usr/local/lib/libguile-2.2.so.0(+0xbc5cd)[0x7f3a6e1465cd]
/usr/local/lib/libguile-2.2.so.0(scm_call_n+0x186)[0x7f3a6e154046]
/usr/local/lib/libguile-2.2.so.0(scm_call_3+0x2f)[0x7f3a6e0d2eaf]
/usr/local/lib/libguile-2.2.so.0(+0xbc5cd)[0x7f3a6e1465cd]
/usr/local/lib/libguile-2.2.so.0(scm_call_n+0x186)[0x7f3a6e154046]
/usr/local/lib/libguile-2.2.so.0(+0xb7fd2)[0x7f3a6e141fd2]
/usr/local/lib/opencog/libsmob.so(_ZN7opencog10SchemeEval7do_evalERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0xb9)[0x7f3a6539be09]
/usr/local/lib/opencog/libsmob.so(_ZN7opencog10SchemeEval11c_wrap_evalEPv+0x1a)[0x7f3a6539beba]
/usr/local/lib/libguile-2.2.so.0(+0x4324a)[0x7f3a6e0cd24a]
/usr/local/lib/libguile-2.2.so.0(+0xbc5cd)[0x7f3a6e1465cd]
/usr/local/lib/libguile-2.2.so.0(scm_call_n+0x186)[0x7f3a6e154046]
/usr/local/lib/libguile-2.2.so.0(+0xb7fd2)[0x7f3a6e141fd2]
/usr/local/lib/libguile-2.2.so.0(+0x43860)[0x7f3a6e0cd860]
/usr/local/lib/libguile-2.2.so.0(scm_c_with_continuation_barrier+0x45)[0x7f3a6e0cd945]
/usr/lib/x86_64-linux-gnu/libgc.so.1(GC_call_with_gc_active+0x77)[0x7f3a6d8438e7]
/usr/local/lib/libguile-2.2.so.0(+0xb6ad1)[0x7f3a6e140ad1]
/usr/lib/x86_64-linux-gnu/libgc.so.1(GC_call_with_stack_base+0x22)[0x7f3a6d83d952]
/usr/local/lib/libguile-2.2.so.0(scm_with_guile+0x38)[0x7f3a6e140e88]
/usr/local/lib/opencog/libsmob.so(_ZN7opencog10SchemeEval9eval_exprERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+0x2e)[0x7f3a6539bf3e]
/usr/local/lib/opencog/modules/libscheme-shell.so(_ZN7opencog12GenericShell9eval_loopEv+0x2ec)[0x7f3a582ea9cc]
/usr/lib/x86_64-linux-gnu/libstdc++.so.6(+0xb8c80)[0x7f3a63f4ac80]
/lib/x86_64-linux-gnu/libpthread.so.0(+0x76ba)[0x7f3a6de716ba]
/lib/x86_64-linux-gnu/libc.so.6(clone+0x6d)[0x7f3a6dba082d]
======= Memory map: ========
00400000-00401000 r-xp 00000000 fd:00 80300005 /usr/local/bin/guile
00600000-00601000 r--p 00000000 fd:00 80300005 /usr/local/bin/guile
00601000-00602000 rw-p 00001000 fd:00 80300005 /usr/local/bin/guile
01d52000-6258b000 rw-p 00000000 00:00 0                                  [heap]
7f3870000000-7f38764e3000 rw-p 00000000 00:00 0 
7f38764e3000-7f3878000000 ---p 00000000 00:00 0 
7f3878000000-7f387c000000 rw-p 00000000 00:00 0 
7f387d7bb000-7f387d7bc000 ---p 00000000 00:00 0 
7f387d7bc000-7f387dfbc000 rw-p 00000000 00:00 0 
7f387dfbc000-7f387dfbd000 ---p 00000000 00:00 0 
7f387dfbd000-7f387e7bd000 rw-p 00000000 00:00 0 
7f387e7bd000-7f387e7be000 ---p 00000000 00:00 0 
7f387e7be000-7f387efbe000 rw-p 00000000 00:00 0 
7f387efbe000-7f387efbf000 ---p 00000000 00:00 0 
7f387efbf000-7f387f7bf000 rw-p 00000000 00:00 0 
7f387f7bf000-7f387f7c0000 ---p 00000000 00:00 0 
7f387f7c0000-7f387ffc0000 rw-p 00000000 00:00 0 
7f387ffc0000-7f387ffc1000 ---p 00000000 00:00 0 
7f387ffc1000-7f38807c1000 rw-p 00000000 00:00 0 
7f38807c1000-7f38807c2000 ---p 00000000 00:00 0 
7f38807c2000-7f3880fc2000 rw-p 00000000 00:00 0 
7f3880fc2000-7f3880fc3000 ---p 00000000 00:00 0 
7f3880fc3000-7f38817c3000 rw-p 00000000 00:00 0 
7f38817c3000-7f38817c4000 ---p 00000000 00:00 0 
7f38817c4000-7f3881fc4000 rw-p 00000000 00:00 0 






12 Feb 2017
-----------------
postgres: change  shared_buffers = 64576MB         # min 128kB
/etc/postgresql/9.5/main/postgresql.conf

apt-get update
apt-get upgrade
apt-get install autoconf-archive autoconf automake
apt-get install libgmp-dev libgc-dev libunistring-dev libffi-dev
apt-get install flex gettext texinfo
git clone git://git.sv.gnu.org/guile.git
cd guile; ./autogen.sh --no-configure;
mkdir build; cd build; ../configure; make -j

apt-get install libpq-dev
apt-get purge unixodbc-dev
apt-get autoremove
install link-grammar-5.3.15
cd relex; git pull; ant; ant install

update pair-count.scm to use URL
(sql-open "postgres:///yue_pairs?user=ubuntu&password=asdf")

lynx https://dumps.wikimedia.org/zhwiki/20170101/zhwiki-20170101-pages-articles.xml.bz2

time bzcat zhwiki-20170101-pages-articles.xml.bz2 |/home/ubuntu/src/relex/src/perl/wiki-scrub.pl

real	39m9.964s
user	39m15.964s
sys	1m14.940s

find wiki-stripped/* |wc 1211823
cd wiki-stripped
/home/ubuntu/src/relex/src/perl/wiki-clean-zh.sh
find  |wc   1018923
cd ..

Portal:
Draft:
模块:

mkdir alpha-pages
cd alpha-pages
~/src/relex/src/perl/wiki-alpha-zh.sh
find |wc  1018946

cd ../..
cp -pr alpha-data/alpha-pages beta-pages

createdb zh_pairs
cat src/atomspace/opencog/persist/sql/multi-driver/atom.sql | psql zh_pairs

cp ~/src/relex/src/split-sentences/nonbreaking_prefixes/* ~/run/nonbreaking_prefixes
cp ~/src/relex/src/split-sentences/split-sentences.pl ~/run

.... etc.


